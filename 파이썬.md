# 파이썬

## 입출력 
* 빠른 입출력, sys 라이브러리를 이용해 빠른 입출력이 가능하다.
* import sys
    * **readlines()와 read()는 백준 제출 시에는 문제없지만, 로컬에선 입력이 끝나질 않는 문제가 있다.**
    * 이는 두 함수가 EOF를 만날 때까지 계속해서 읽고 있기 때문이다. 백준에서는 자동으로 EOF를 넣어준다.
    * 로컬에서 두 함수를 사용한 코드를 실행하기 위해선, 입력 후 엔터 한 번 + 'ctrl + d'로 EOF를 입력해주고 다시한번 엔터를 쳐서 stdin을 닫아주면 된다.
    * sys.stdin.readline()
        * 한 줄씩 문자열로 읽는다. 명령어 실행 후 입력 포인터가 다음줄로 이동한다.
    * ~.readlines()
        * 파일 전체를 가져와 리스트로 반환한다. 각 줄을 문자열 형태로 리스트에 저장한다.
    * ~.read()
        * readlines()와 마찬가지로 파일 내용 전체를 읽고, 파일 내용 전체를 하나의 문자열로 반환한다. 각 줄은 개행문자로 구분된다.
* 기본 입출력
    * print()
        * print 함수는 sep, end 등의 delimeter를 사용하여 다양한 출력기능을 포함할 수 있다.
        * print안에 애스터리스크'*'가 들어가면 unpacking을 의미한다.
    * input()
        * input()은 문자열, 한 라인의 입력을 받는다.
        * 따라서 input()해 온 값은 string이다.
        *
* EOF 문제를 해결하는 방법
    * 입력의 갯수를 모를 때, 즉 파일의 끝(EOF)까지 입력을 받아야 할 때 사용할 수 있는 방법
        1. sys.stdin.readlines()와 read()
            * read()는 통째로 하나의 string으로, readlines()는 한줄씩 리스트의 원소로 넣어서 반환한다.
        2. 'for _ in sys.stdin'으로 리스트 컴프레헨션을 사용하는 방법
            ```
            example = list(element.rstrip() for element in sys.stdin)
            ```
            * *이 방법도 **readlines()와 비슷하게 줄단위로 끊지만, 요소 하나씩을 읽어오기 때문에 입력과 동시에 rstrip() 등 가공이 가능하다.**


## 자료형
* string
    * 파이썬에서 string은 str로 사용한다.
    * 문자형수 ex) ex = "8467"
        * 문자형 수의 경우 sorted(ex)를 할 경우 ['4', '6', '7', '8']처럼 정렬된 list를 반환한다.
* list
    * 파이썬의 list는 자바의 array-list에 추가된 기능을 지원한다.
    * list에는 다양한 타입의 값이 들어갈 수 있다.
    * list 초기화 방법
        1. sample_list = list(n)
        2. sample_list = []s
    * list 관련 연산자
        1. a 'in' B, O(n) : 리스트 B에 a요소가 있는지 확인
        2. sort()
            * sort()는 실제로 변경하고 sorted()는 실제론 변경되지 않으며 변경된 값을 리턴만한다.
            * sort()는 key값을 이용해서 정렬할 수 있다.
        3. '구분자'.join(리스트) 
            * join() 함수는 매개변수로 들어온 리스트에 있는 요소 하나하나를 합쳐 하나의 문자열로 반환한다.
            * 리스트의 값과 값 사이에 구분자를 넣어서 하나의 문장열로 합친다.
* set(집합)
    * 집합 자료형은 중복을 허용하지 않으며, 순서가 없다.
    * 특정 상황에서 집합 자료형을 사용하면, 리스트를 이용하는 것보다 훨씬 빠른 처리가 가능하다.
    * set을 이용하면 두 집합간의 교집합(&), 합집합(|), 차집합(-) 등을 쉽고 빠르게O(len(n) + len(m))구할 수 있다.
* dictionary(hash)
    * 파이썬 3.6 이후부터는 dict 자료형이 순서를 기억한다.
    * 딕셔너리는 key와 value를 한 쌍으로 갖는 자료형이다.
    * list나 tuple처럼 인데스를 이용해 (순차적으로)해당 요소값을 구하지않고 key를 통해 value를 얻는다.
    * 딕셔너리의 key는 변하지 않는 값이어야 한다. 따라서, tuple을 key값으로 쓸 수 있지만 list는 key값으로 사용하지 못 한다.
    * dictionary 관련 함수
        1. get()
            * dic.get(key)는 key값에 해당하는 value를 반환한다.
            * 일반적인 상황에서 dic[key]를 사용하는 것과 비슷하지만, key값이 존재하지 않을 경우
            * []는 오류를 발생시키고 get() 함수는 None을 반환한다.
            * get(key, "디폴트")를 사용해서딕셔너리안에 찾으려는 key가 없을 경우 미리 정해둔 디폴트 값을 반환하게 할 수 있다.
        2. dict.fromkeys() 
            * key값으로 딕셔너리를 만든다. **리스트 중복제거에도 사용**
            * 특히, 리스트 중복제거로 사용 시 **동일 원소가 처음 나왔을 때를 기준으로 만들어진다는 것을 기억**
            * key값을 저장한 배열이나, 튜플 등을 매개변수로 받음(필수), value값도 배열이나 튜플로 매개변수로 전달할 수 있음(선택)
            * value를 지정하지 않을 시, None이 default로 설정된다.
        3. dict.items() 
            * key와 value 쌍을 튜플로 묶은 값을 dict_items 객체로 돌려준다.
            ㅠ


## 연산자
* 증감연산자
    * 파이썬에는 증감연산자인 ++, -- 연산자가 없다.

* **if __name__ == '__main__'**
* 위 코드는 현재 스크립트 파일이 프로그램의 시작점이 맞는지 판단한다. 
* 즉, 스크립트 파일이 메인으로 사용되는지, 모듈로 사용되는지를 구분하기 위한 용도이다
    * 파이썬은 외관상 시작점과 모듈의 차이가 없다.
    * 이 때문에 모든 스크립트 파일은 시작점이 될 수도, 모듈로 사용될 수도 있다.
    * "__name__"은 현재 파일의 이름을 가지고있다.


## 함수
* enumerate(), 열거
    * enumerate() 함수는 list, set, tuple, dictionary, string을 입력받아 인덱스 값을 포함하는 enumerate 객체를 리턴한다.
        ```
        dict1 = {'이름': '한사람', '나이': 33}
        data = enumerate(dict1)
        for i, key in data:
            print(i, ":", key, dict1[key])
        ```
        ```
        0 : 이름 한사람
        1 : 나이 33
        ```
    * enumerate 함수는 set, dictionary를 포함해 순서가 있는 자료형을 받아 순서와 값을 전달한다.

* zip()
    * zip() 함수는 여러 개의 순회 가능한(iterable) 객체를 인자로 받고, 각 객체가 담고 있는 원소를 튜플의 형태로 차례로 접근할 수 있는 반복자(iterator)를 반환한다.
        ```
        numbers = [1, 2, 3]
        letters = ["A", "B", "C"]
        for pair in zip(numbers, letters):
            print(pair)
        ```
        ```
        (1, 'A')
        (2, 'B')
        (3, 'C')
        ```


## 라이브러리
* **from bisect import bisect_left, bisect_right**
    * bisect : 이진탐색 라이브러리. 정렬된 배열에서 특정한 원소를 찾아야할 때 사용한다.
        * bisect_left(a, x) : 정렬된 순서를 유지하면서, 리스트 a에 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드. O(log(N))
        * bisect_right(a, x) : 정렬된 순서를 유지하도록 리스트 a에 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드. O(log(N))
    * 위 라이브러리 함수를 이용하여, **값이 특정 범위에 속하는 원소의 개수**를 쉽게 구할 수 있다.
* **from collections import Counter**
    * Counter : 리스트에서 요소의 갯수를 카운팅하는 라이브러리. **dict형으로 반환한다.**
    * 따라서 dictionary의 모든 연산을 사용할 수 있다.
        * counter.total() : 모든 counter 요소 갯수의 합을 구한다.