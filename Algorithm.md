## 알고리즘
알고리즘 트레이닝, 프로그래밍 대회 입문 가이드.

### 1장
* 경진 프로그래밍 = 알고리즘 설계 + 구현
* 요점 : 문제 해결 능력 향상과 간단한 도구를 이용하여 어려운 문제를 푸는 방법
* CSES 문제 셋 : [Code Submission Evaluation system](https://cses.fi/problemset)
* 코딩테스트 시, 알고리즘의 채점은 데이터셋의 입력에 대한 결과로 확인하기 때문에 알고리즘은 정확했다 해도 구현 시 문제가 발생할 수 있다.
* 예를 들어 수의 자료형을 int로 했을 경우, 입력 데이터셋의 연산결과가 int 자료형의 범위를 벗어난다면 예상치 못한 결과가 나올 수 있다. 

### 2장
* C++ 언어의 특성
 * C++ 코드 템플릿
  #include <bits/stdc++.h> : 표준 라이브러리 전체를 포함시키는 g++컴파일러의 기능
  g++ -std=c++11 -02 -Wall test.cpp -o test : 작성한 코드를 컴파일하는 명령어, test.cpp 를 컴파일해서 test 실행파일 생성
  컴파일러는 c++11 표준을 따르고 코드를 최적화하면(-02), 발생 가능한 오류에 대한 경고를 띄운다(-Wall)
 * 입력 데이터셋
  입력 데이터셋은 일반적으로 공백이나 개행문자로 구분된 문자열 및 수로 이뤄져있다.
  c++에서는 이러한 입력을 'cin >> a >> b >> x;' 로 처리한다. 입력 원소 사이에 적어도 한개의 공백이나 개행문자가 존재할 경우 이런 형태의 코드는 항상 문제없이 작동한다.
  1) 123 456 example
  2) 123   456
     example
  위 1, 2 모두에서 정상적으로 작동한다.
  공백을 포함한 채로, 입력한 줄을 통째로 읽어들이기 위해서 getline 함수를 사용한다
  string s;
  getline(cin, s);
  
  만일 데이터의 양을 사전에 알 수 없는 경우 아래와 같이 작성한다
  while (cin >> x) {}

 * 효율적인 입출력
  효율적인 출력을 위해선 endl 대신 '\n'을 사용하는 것이 좋다. endl을 사용할 경우 명시적인 플러시가 일어나기 때문에 개행문자를 사용하는 것이 빠르다.
  간혹 입출력이 프로그램의 병목이 될때면, 코드 시작 부분에 아래와 같은 코드를 추가해 입출력을 좀 더 효율적으로 할 수 있다.
   ios::sync_with_stdio(0);
   cin.tie(0);
  다만 이와 같은 경우 C언어 입출력함수(scanf, printf)를 C++ 입출력함수와 동시에 사용할 수 없다. (일반적으로 C언어의 입출력이 더 빠르다)
  int a, b;
  scanf("%d %d",&a,&b);
  printf("%d %d\n",a,b);

 * 대회, 입출력 파일 시스템
  몇몇 대회 시스템은 입출력을 위해 파일을 사용하기도 한다. 이를 간단하게 처리하기 위해 평소처럼 표준스트림을 사용하는 코드를 작성 후,
  아래 두 줄을 코드의 시작부분에 추가한다.
  freopen("input.txt", "r", stdin);
  freopen("output.txt", "w", stdout);

 * 부동소수점 실수의 정밀도
  몇몇 문제들은 출력에 대해 특정한 정밀도를 요구한다. 이에 맞춰 답을 출력하는 가장 간단한 방법은 printf 함수를 사용하고 형식문자열에 답의 소수점 아래 자릿수를 명시한다.
  printf("%.9f\n", x); 소수점 아래 9자리까지만 출력한다.

* 수를 처리하는 방법
 * 정수자료형은 int를 기본으로, 부족하다면 'long long' 자료형을 쓴다.
 long long x = 123456789123456789LL;    LL은 이 정수값의 자료형이 long long임을 의미한다.
 아래와 같은 코드는 예상치 못 한 결과를 초래한다
 int a = 123456789;
 long long b = a * a;
 문제를 해결하기 위해선 a의 자료형을 long long으로 바꾸거나, 계산식을 '(long long)a * a'로 수정한다.
 이 외에 g++ 컴파일러는 128비트 자료형인 __int128_t를 지원한다.

 * modulo 연산
  나머지 연산을 수행할 때 다음과 같은 공식이 성립한다
   (a+b) mod m = (a mod m + b mod m) mod m
   (a-b) mod m = (a mod m - b mod m) mod m
   (a*b) mod m = (a mod m * b mod m) mod m
  음수의 나머지를 구하는 경우, 나머지 연산 수행후에 결과에 m을 더해준다.

 * 부동 소수점 실수
  일반적으로 64bit, double을 많이 사용하고 g++ 컴파일러가 지원하는 확장 자료형인 80bit, long double도 유용하다.
  다만 부동소수점을 사용할 때 어려운 점은 부동소수점수는 정확하게 표현이 안 된다는 점이다.
  따라서 부동 소수점 실수를 비교할 때에는 '=='연사자를 사용하기보다 두 수의 차이가 입실론보다 작을 때 일치한다고 판단하는 것이 더 나은 방법이다.
  부동 소수점 실수는 일반적으로 부정확하지만 특정 범위까지의 정수는 정확하게 표현 가능하다. 예로 double의 경우 절대값이 2^53 이하인 모든 정수를 정확하게 표현가능하다.

 * 코드 짧게 만들기
  * typedef을 통해 자료형의 이름을 짧게 만들 수 있다.
     typedef long long ll;
     ll a = 123456789LL;
   이 외에도 vector<>, pair<,> 등의 자료형에도 사용할 수 있다.
 
  * 매크로(macro) 이용
  매크로는 코드를 컴파일하기 전에 코드에 포함된 특정 문자열을 다른 문자열로 치환하는 규칙이다.
   #define 지시문을 통해 매크로를 정의할 수 있다.
    #define F first
    #define S second
  매크로를 이용하면 자주 사용되는 메소드나 변수의 이름 등을 간략화 할 수 있다.
  아래와 같은 방법으로 매크로에 인자를 줄수도 있다.
  #define REP(i,a,b) for (int i = a; i <= b; i++)

* 재귀(Recursion)적 알고리즘
 * 부분집합 생성하기
 * 순열 생성하기
 * 퇴각 검색(Backtracking)

* 비트 연산
 * C++의 int는 부호비트가 존재하는 자료형이다. 따라서 32비트인 int는 -2^31 ~ 2^31-1 까지의 수를 표현 가능하다.
 * 또한 이런 자료형은 2의 보수 표현법을 사용한다.
 * C++에서는 부호가 없는 정수표현도 제공한다. unsigned int는 0부터 2^32-1가지의 값을 가질 수 있다.
  수의 표현 방법에 따라 다음의 예제가 성립한다
  int x = -43;  **x = -43**
  unsigned int y = x;  **'y = 4294967253' == 2^32 - 43**
 * 
  