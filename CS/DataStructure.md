# 자료구조

## 2. 순환, Recursion
* 순환이란, 자기 자신을 호출하여 문제를 해결하는 프로그램.
* 순환 호출의 내부적인 구현
    1. 함수가 자기를 다시 호출하는 것은 다른 함수를 호출하는 것과 동일하다.
    2. 즉, 복귀주소가 시스템 스택에 저장되고 호출되는 함수를 위한 매개변수와 지연변수를 스택으로부터 할당받는다.
    3. 위와 같은 함수를 위한 시스템 스택에서의 공간을 활성레코드(activation record)라고 한다.
    4. 준비가 끝나면 호출된 함수의 시작 위치로 점프하여 수행한다.
    5. 호출된 함수가 끝나면 시스템 스택에서 복귀주소를 추출하여 호출한 함수로 되돌아간다.
    * 함수호출마다 새로운 지역변수를 만들지 못하면 이전 호출과 구분할 수 없으므로 순환 호출이 불가하다.
* 순환 알고리즘의 구조
    * 순환 알고리즘은 자기자신을 순환호출하는 부분과 순환호출을 멈추는 부분으로 구성된다.
    * 분할정복방법(divide and conquer) : 문제의 일부를 해결할 다음, 나머지 문제에 대해 순화호출한다. 
    * 따라서 순환호출이 일어날 때마다 문제의 크기가 작아진다.
* 반복(iteration)과 순환의 관계
    * 기본적으로 반복과 순환은 문제해결능력이 같다.
    * 순환호출이 끝에서 일어나는 꼬리순환(tail recursion)의 경우, 반복으로 쉽게 바꾸어 쓸 수 있다.
    * 순환의 경우 몇몇 알고리즘에서 명확하고 간결하게 나타낼 수 있다는 장점이 있다.
    * 순환은 함수호출로 인한 오버헤드로 일반적인 경우 반복을 사용하는 것이 빠르다.
* 대표적인 순환 알고리즘
    * 순환이 반복보다 빠른 대표적인 예로, 거듭제곱값 계산이 있다. 순환은 O(log(n)), 반복은 O(n)으로 순환이 더 빠르다.
    * 피보나치의 경우 순환을 사용하면 자연스러운 알고리즘 작성이 가능하지만, 속도가 매우 느려지는 대표적인 예이다.

- - -
    * 반복적인 형태로 바꾸기 어려운 순환
     1. return n* factorial(n-1);
     2. return factorial(n-1) *n;
     * 1과 같이 순환 호출이 순환 함수의 맨 끝에서 이루어지는 것을 꼬리 순환이라고 한다. 이는 쉽게 반복으로 변환이 가능하다.
     * 2와 같은 머리순환의 경우나 하노이탑 문제처럼 여러 군데에서 자기 자신을 호출하는 경우는 쉽게 반복으로 바꿀 수 없다.
     * 따라서 동일한 알고리즘을 머리순환과 꼬리순환 모두로 작성할 수 있다면 당연히 꼬리 순환으로 작성해야 한다.
- - -
* 책에 설명에 오류가있어, 위 내용을 수정한다.
* [What is tail recursion?](https://stackoverflow.com/questions/33923/what-is-tail-recursion?newreg=9204514db4b647e2a3f00c669ebd6e2d)
* Head recursion은 위에 1, 2의 경우를 모두 포함한다. 즉, Head recursion은 순환호출이 일어나면서 시스템 스택에 함수가 종료되지 않고 쌓인 후, 하나 씩 해결되며 종료된다.
* Tail recursion의 경우, 함수가 순환호출을 할 때 자기가 맡은 일을 끝내고 다음 함수를 호출한다. return에 더 이상의 계산식이 없이 함수호출 부분만이 존재한다.

    * Head Recursion
    ```
    function recsum(x) {
        if (x === 0) {
            return 0;
        } else {
         return x + recsum(x - 1);
        }
    }
    ```

    * Tail Recursion
    ```
    function tailrecsum(x, running_total = 0) {
     if (x === 0) {
         return running_total;
     } else {
         return tailrecsum(x - 1, running_total + x);
     }
    }
    ```

## 3. 배열, 구조체, 포인터
* 배열(array)
    * 동일한 타입에 데이터를 저장
    * 많은 자료구조들이 배열을 사용하여 구현된다.
* 배열 ADT(Abstract Data Type)
    * 생각해보면 배열은 <인덱스, 값> 쌍의 집합이라고 볼 수 있다.
    * 배열은 주어진 인덱스에 값을 저장하는 set, 값을 추출하는 get 연산 등을 수행한다.
    * 컴파일러는 배열에 메모리를 연속된 위치에 할당한다. 인덱스 0이 기본주소(base)가 되고 다음 주소를 구하기 위해선 1씩 더한다.(base+1*sizeof(int))
* 2차원 배열
    * c언어에서 2차원 배열은 'int list[3][5];'의 형식으로 선언된다.
    * 즉, 배열에 배열을 만들어서 2차원 배열을 구현한다. 위의 예시에선 크기가 3인 배열을 만들고 이 배열의 요소로 크기가 5인 배열을 생성하여 추가한다.

* 구조체(structure)
* 타입이 다른 데이터를 묶는 방법, 일반적으로 struct 키워드 이용
    1. struct 구조체태그 {
    2.      항목1; 
    3.      항목2;
    4. };    
* typedef 구조체 정의
    * 아래 예에서는 student가 새로운 데이터 타입의 이름이 된다.
        1. typedef struct studentTag {
        2.      char name[10];
        3.      int age;
        4. } studnet;
    * 구조체는 중괄호를 사용하여 선언 시에 초기화 할 수 있다.
        1. student s = { "Jang", 23 };

* 배열의 응용 : 다항식
* 배열을 이용해서 수학에서 나오는 다항식을 나타내는 두가지의 자료구조를 생각할 수 있다.
    * 첫번째 방법 : 모든 항의 계수를 배열에 저장하고 최고차항을 degree 변수에 저장
        * 다항식 구조체는 'int degree'와 'float coef[MAX_DEGREE+1]'을 필드로 갖는다.
        * 간단하지만, 대부분의 항의 계수가 0인 희소 다항식의 경우 공간 낭비가 심하다.
        * 덧셈이나 뺄셈 시 같은 차수의 계수를 쉽게 찾을 수 있다.
    * 두번째 방법 : 0이 아닌 항만을 하나의 구조체 배열에 저장한다. 즉, 각 항을 (계수, 차수)의 구조체 형식으로 만들고 배열에 넣는다.
        * 'float coef'와 'int expon' 필드를 갖는 구조체의 배열이다.
        * 많은 다항식을 저장할 수 있다.
        * 하나의 다항식이 시작되고 끝나는 인덱스를 관리해야 한다.
        * 다항식의 연산을 구현하는 것이 어려워진다. 또한, 다항식에 따라서는 첫번째 방법보다 공간을 더 많이 필요로 할 수 있다.

* 배열의 응용 : 희소행렬
* 배열을 이용해서 행렬을 나타낼 수 있다.
    * 첫번째 방법 : 이차원 배열을 사용한다.
        * 가장 자연스러운 방법이다.
        * 배열을 나타내고, 확인 및 계산하기에 가장 간편하다.
        * 다항식과 마찬가지로 희소행렬의 경우 공간 낭비가 심하다.
        * 'int matric[rows][columns]'과 같이 선언한다.
    * 두번째 방법 : 값이 0이 아닌 위치만 포함하는 구조체 배열을 포함하는 구조체로 만든다.
        * 구조체 배열은 다음과 같은 모습이다.
        ```
        typedef struct {
            int row;
            int column;
            int value;
        } element;
        ```
        * 위에 element배열을 요소로 갖는 matrix 구조체를 만든다.
        ```
        typedef struct matrix {
            element data[MAX_TERMS];
            int rows;
            int columns;
            int terms;
        } matrix;
        ```
        * 이렇게 두번째 방법은 0이 많은 행렬에서 공간 효율적이지만, 계산이 복잡해진다는 단점이 있다.

* 포인터 : 주소를 갖는 변수
* 모든 변수는 메모리 공간에 저장되며, 메모리의 각 바이트에는 주소가 매겨져있다.
    ```
    int a = 100;
    int *p;
    p = &a;
    ```
    1. 메모리공간에 변수 a를 선언함과 동시에 100으로 초기화한다.
    2. int형를 가리키는 포인터 변수 p를 선언한다.
    3. p의 값으로 a의 주소를 대입한다.
* 포인터와 관련된 연산자
    * "&" : 주소 연산자, 변수의 주소를 추출하는 연산자
    * "*" : 간접참조 연산자, 포인터가 가리키는 장소에 값을 저장하는 연산자
* 널 포인터
    * 널 포인터는 어떤 객체도 가리키는 않는 포인터이다. 
    * **포인터를 사용하기 전에는 반드시 널 포인터인지 검사해야한다.**
    * 잘못된 포인터를 가지고 메모리를 변경하는 경우 치명적인 결과를 불러올 수 있는데,
    * 널 포인터에 참조하려고 하면 오류가 발생하기 때문에 쉽게 파악이 가능하다.
    * 따라서 포인터가 아무것도 가리키고 있지 않을 때는 항상 널 포인터 상태롤 만들어 두는 것이 좋다.
* 배열과 포인터
    * 포인터를 사용하면 함수에 값을 전달해서, 내부에서 매개변수 값을 변경할 수 있다.
    * 다만, 배열을 포인터를 사용하지 않아도 값이 변경 가능하다. 이는 **배열의 이름이 배열의 첫번째 원소를 가리키는 포인터이기 때문이다.**
    * 다시말해 배열을 선언하고 초기화하면, 배열의 이름에는 배열의 첫번째 원소의 주소가 저장된다.
    * 일반적으로 변수가 call by value로 함수에 전달될 때, 변수 값에 대한 복사가 일어난다.
    * c언어에서는 배열의 이름이 포인터이기 때문에, 배열에 대한 복사가 일어나지 않아 더 빠르고 공간 효율적인 프로그램 작성이 가능하다.
    * **'int arr[10];'과 같이 정적할당 되는 배열은 스택영역에 생성된다.**   
* 동적메모리 할당, Dynamic memory allocation
* 프로그램 작성 당시에는 입력의 크기를 알 수 없는 경우가 많다. 이에따라 발생하는 문제들을 해결하기 위해 C언어에서는
* 필요한만큼의 메모리를 운영체제로부터 할당받아 사용하고, 사용이 끝나면 시스템에 반납하는 기능이 있다. 이를 동적 메모리 할당이라고 한다.
* **동적 메모리는 메모리공간 중 '힙(heap)영역'에 할당된다.** 힙은 운영체가자 사용되지 않는 메모리 공간을 모아놓은 공간이다.
    ```
    int *p;
    p = (int *)malloc(sizeof(int));     # 동적 메모리 할당
    *p = 1000;          # 동적 메모리 사용
    free(p);            # 동적 메모리 반납
    ```
    1. malloc()은 size바이트 만큼의 메모리 블록을 할당한다. sizeof 키워드는 변수나 타입의 크기를 숫자로 반환한다.
    2. malloc()은 동적메모리 블럭의 시작주소를 반환한다. 반환되는 주소는 'void *'타입이므로 형변환 해서 사용한다.
    3. 동적 메모리는 포인터로만 사용가능하다. free()함수는 할당된 메모리 블록은 운영체제에 반납한다. 
    4. 메모리 반환을 위해선 할당받은 포인터 값을 기억해야한다. malloc() 함수가 반환했던 포인터 값을 잊어버리면 반환할 수 없다..
    5. **malloc은 메모리를 할당할 수 없으면 NULL을 반환한다. 따라서 malloc()의 반환값은 항상 NULL검사를 해야한다.**
    
    * 정수 10개를 저장할 수 있는 동적메모리 할당
    ```
    #define SIZE 10
    int *p;
    p = (int *)malloc(SIZE * sizeof(int));
    if (p == NULL) {
        fprintf(stderr, "할당할 수 있는 메모리가 없습니다.");
        exit(1);
    }
    for (int i=0; i<SIZE; i++) {
        p[i] = i;
    }
    for (int i=.; i<SIZE; i++) {
        printf("%d ", p[i]);
    }
    free(p)
    ```
* 구조체와 포인터
    * 구조체도 물론, 구조체 포인터를 선언하고 이를 통해 구조체 멤버에 접근할 수 있다.
    * '*'와 '.'연산자를 이용하여 구조체 멤버에 접근할 수도 있지만, 일반적으로 더 편리한 '->'를 자주 사용한다.
    * C에서는 자주 함수의 매개변수로 구조체가 전달된다. 구조체 자제를 함수로 전달하는 경우,
    * 구조체가 복사되어 전달되기 때문에, 큰 구조체의 경우에는 구조체 포인터를 전달하는 것이 좋다.