## 알고리즘
알고리즘 트레이닝, 프로그래밍 대회 입문 가이드.

### 1장
* 경진 프로그래밍 = 알고리즘 설계 + 구현
* 요점 : 문제 해결 능력 향상과 간단한 도구를 이용하여 어려운 문제를 푸는 방법
* CSES 문제 셋 : [Code Submission Evaluation system](https://cses.fi/problemset)
* 코딩테스트 시, 알고리즘의 채점은 데이터셋의 입력에 대한 결과로 확인하기 때문에 알고리즘은 정확했다 해도 구현 시 문제가 발생할 수 있다.
* 예를 들어 수의 자료형을 int로 했을 경우, 입력 데이터셋의 연산결과가 int 자료형의 범위를 벗어난다면 예상치 못한 결과가 나올 수 있다. 

### 2장
* C++ 언어의 특성
    * C++ 코드 템플릿
        * #include <bits/stdc++.h> : 표준 라이브러리 전체를 포함시키는 g++컴파일러의 기능
        * g++ -std=c++11 -02 -Wall test.cpp -o test : 작성한 코드를 컴파일하는 명령어, test.cpp 를 컴파일해서 test 실행파일 생성
        * 컴파일러는 c++11 표준을 따르고 코드를 최적화하면(-02), 발생 가능한 오류에 대한 경고를 띄운다(-Wall)
    * 입력 데이터셋
        * 입력 데이터셋은 일반적으로 공백이나 개행문자로 구분된 문자열 및 수로 이뤄져있다.
        * c++에서는 이러한 입력을 'cin >> a >> b >> x;' 로 처리한다. 입력 원소 사이에 적어도 한개의 공백이나 개행문자가 존재할 경우 이런 형태의 코드는 항상 문제없이 작동한다.
            1. 123 456 example
            2. 123   456 
               example
        * 위 1, 2 모두에서 정상적으로 작동한다.
        
        * 공백을 포함한 채로, 입력한 줄을 통째로 읽어들이기 위해서 getline 함수를 사용한다
            1. string s;
            2. getline(cin, s);

        * 만일 데이터의 양을 사전에 알 수 없는 경우 아래와 같이 작성한다
            1. while (cin >> x) {}

    * 효율적인 입출력
        * 효율적인 출력을 위해선 endl 대신 '\n'을 사용하는 것이 좋다. endl을 사용할 경우 명시적인 플러시가 일어나기 때문에 개행문자를 사용하는 것이 빠르다.
        * 간혹 입출력이 프로그램의 병목이 될때면, 코드 시작 부분에 아래와 같은 코드를 추가해 입출력을 좀 더 효율적으로 할 수 있다.
            1. ios::sync_with_stdio(0);
            2. cin.tie(0);
        * 다만 이와 같은 경우 C언어 입출력함수(scanf, printf)를 C++ 입출력함수와 동시에 사용할 수 없다. (일반적으로 C언어의 입출력이 더 빠르다)
            1. int a, b;
            2. scanf("%d %d",&a,&b);
            3. printf("%d %d\n",a,b);

    * 대회, 입출력 파일 시스템
        * 몇몇 대회 시스템은 입출력을 위해 파일을 사용하기도 한다. 이를 간단하게 처리하기 위해 평소처럼 표준스트림을 사용하는 코드를 작성 후,
        * 아래 두 줄을 코드의 시작부분에 추가한다.
            1. freopen("input.txt", "r", stdin);
            2. freopen("output.txt", "w", stdout);

    * 부동소수점 실수의 정밀도
        * 몇몇 문제들은 출력에 대해 특정한 정밀도를 요구한다. 이에 맞춰 답을 출력하는 가장 간단한 방법은 printf 함수를 사용하고 형식문자열에 답의 소수점 아래 자릿수를 명시한다.
        * printf("%.9f\n", x); 소수점 아래 9자리까지만 출력한다.

* 수를 처리하는 방법
    * 정수자료형은 int를 기본으로, 부족하다면 'long long' 자료형을 쓴다.
        * long long x = 123456789123456789LL;    LL은 이 정수값의 자료형이 long long임을 의미한다.
        * 아래와 같은 코드는 예상치 못 한 결과를 초래한다
            1. int a = 123456789;
            2. long long b = a * a;
        * 문제를 해결하기 위해선 a의 자료형을 long long으로 바꾸거나, 계산식을 '(long long)a * a'로 수정한다.
        * 이 외에 g++ 컴파일러는 128비트 자료형인 __int128_t를 지원한다.

    * modulo 연산
        * 나머지 연산을 수행할 때 다음과 같은 공식이 성립한다
            * (a+b) mod m = (a mod m + b mod m) mod m
            * (a-b) mod m = (a mod m - b mod m) mod m
            * (a*b) mod m = (a mod m * b mod m) mod m
        * 음수의 나머지를 구하는 경우, 나머지 연산 수행후에 결과에 m을 더해준다.

    * 부동 소수점 실수
        * 일반적으로 64bit, double을 많이 사용하고 g++ 컴파일러가 지원하는 확장 자료형인 80bit, long double도 유용하다.
        * 다만 부동소수점을 사용할 때 어려운 점은 부동소수점수는 정확하게 표현이 안 된다는 점이다.
        * 따라서 부동 소수점 실수를 비교할 때에는 '=='연사자를 사용하기보다 두 수의 차이가 입실론보다 작을 때 일치한다고 판단하는 것이 더 나은 방법이다.
        * 부동 소수점 실수는 일반적으로 부정확하지만 특정 범위까지의 정수는 정확하게 표현 가능하다. 예로 double의 경우 절대값이 2^53 이하인 모든 정수를 정확하게 표현가능하다.

* 코드 짧게 만들기
    * typedef을 통해 자료형의 이름을 짧게 만들 수 있다.
        1. typedef long long ll;
        2. ll a = 123456789LL;
    * 이 외에도 vector<>, pair<,> 등의 자료형에도 사용할 수 있다.
 
* 매크로(macro) 이용
    * 매크로는 코드를 컴파일하기 전에 코드에 포함된 특정 문자열을 다른 문자열로 치환하는 규칙이다.
    * #define 지시문을 통해 매크로를 정의할 수 있다.
        1. #define F first
        2. #define S second
    * 매크로를 이용하면 자주 사용되는 메소드나 변수의 이름 등을 간략화 할 수 있다.
    * 아래와 같은 방법으로 매크로에 인자를 줄수도 있다.
        1. #define REP(i,a,b) for (int i = a; i <= b; i++)

* 재귀(Recursion)적 알고리즘
    * 부분집합 생성하기
    * 순열 생성하기
    * 퇴각 검색(Backtracking)

* 비트 연산
    * C++의 int는 부호비트가 존재하는 자료형이다. 따라서 32비트인 int는 -2^31 ~ 2^31-1 까지의 수를 표현 가능하다.
    * 또한 이런 자료형은 2의 보수 표현법을 사용한다.
    * C++에서는 부호가 없는 정수표현도 제공한다. unsigned int는 0부터 2^32-1가지의 값을 가질 수 있다.
    * 수의 표현 방법에 따라 다음의 예제가 성립한다
        1. int x = -43;  **x = -43**
        2. unsigned int y = x;  **'y = 4294967253' == 2^32 - 43**
    
    * AND(&) 연산
        * And 연산을 이용하면 어떤 정수 x가 홀수인지 짝수인지 알 수 있다. 짝수이면 x & 1 = 0, 홀수이면 x & 1 = 1이다.
        * 이를 일반화해서 x가 2^k로 나누어떨어지는 경우는 x & 2^k-1 = 0 일 때이다.
    * OR(|), XOR(^)
    * NOT(~) 연산
        * ~x = -x-1임이 성립한다.
    * 비트 시프트 연산 (<<), (>>)
        * 좌측 시프트 연산 'x<<k' 는 정수의 오른쪽에 비트 0을 k개 덧붙이고, 우측 시프트 연산 'x>>k'는 정수의 오른쪽 비트 k개를 제거하는 연산이다.
        * 각각 x에 2^k를 곱한것과 x를 2^k로 나눈 후 정수로 내림한 것과 같다.
        * 주의할 점. 비트 시프트 연산의 결과는 항상 int형이다. '1LL<<k'와 같은 방법으로 long long형 정수에 비트 연산을 할 수 있다.
    
    * g++ 컴파일가 제공하는 기능
        * __builtin_clz(x) : 왼쪽끝부터 연속해서 있는 비트 0의 개수
        * __builtin_ctz(x) : 오른쪽끝부터 연속해서 있는 비트 0의 개수
        * __builtin_popcount(x) : 비트 1의 개수
        * __builtin_parity(x) : 비트 1에 대한 패리티 (1이면 홀수)
        * int형만 지원되며, 함수이름 뒤에 ll을 덧붙이면 long long형 정수를 지원하는 함수가 된다.
    
    * 집합 표현
        * 집합 {0,1,2,...,n-1}의 모든 부분지합을 n비트 정수를 이용하여 표현할 수 있다.
        * 예를 들어 int형 정수는 32bit이므로 {0,1,...,31}의 모든 부분집합을 표현 가능하다.
        * 집합 {1,3,4,8}의 경우 00000000000000000000000100011010로 나타낸다. 이에 대응되는 정수는 282이다.
            1. int x=0;
            2. x |= (1<<1);
            3. x |= (1<<3);
            4. x |= (1<<4);
            5. x |= (1<<8);
            6. cout << __builtin_popcount(x);   // 4
        * 집합에 대한연산 또한 비트연산으로 구현할 수 있다.
            * 합집합은 두 집합의 '|'연산으로 표현할 수 있다.
            * 교집합은 '&'연산을 수행한 것과 같다.
            * 여집합은 '~'연산과 같다.
            * 차집합은 'a&(~b)'를 수행한 것과 같다.
        
        * 비트셋(bitset) 자료구조
            * C++ 표준 라이브러리에서 제공하는 자료구조
            * 원소가 0또는 1인 배열로 쓸 수 있다.
            * count() 함수는 비트셋에 포함된 비트 1의 개수를 반환한다.
            * 비트연산을 비트셋에 대해 그대로 적용할 수 있다.


### 3장.효율성
* 시간복잡도 
    * 시간복잡도는 알고리즘의 효율성을 근사적으로 측정하는 도구
    * 입력 n에 대한 시간 복잡도를 O(...)형식으로 괄호안에는 n에대한 함수로 표현.
* 계산규칙
    * 빅오를 이용해 시간복잡도를 표현할 떄에는, 함수의 차수만을 생각한다.
    * 알고리즘이 여러 단계로 구성되면, 전체시간복잡도는 시간복잡도 중 제일 큰 것이 된다.
    * 가장 느린 단계가 알고리즘의 병목이 되기 때문이다.
    * 시간복잡도가 여러 인자에 영향을 받으면 시간 복잡도 함수에 여러 변수가 포함될 수 있다. ex) O(mn)
    * 재귀함수의 시간복잡도는 함수가 몇 번 호출되는지, 각 호출 때 시간 복잡도가 어떻게 되는지에 따라 결정된다.
    * 재귀함수의 전체시간복잡도는 이 둘을 곱합 형태가 된다.
* 자주 접할 수 있는 시간복잡도
    * O(1), Constant time algorithm : 입력에 크기에 영향X, ex) 공식을 이용해 답을 바로 계산
    * O(log(n)), Logarithmic algorithm : 단계마다 입력의 크기를 절반씩 줄여나간다. 로그의 밑수가 시간 복잡도에 나타나 있지않다.
    * O(sqrt(n)), Square root alg.. : 제곱근의 성질 'sqrt(n) = n/sqrt(n)'. 따라서 n개의 원소를 각각 O(sqrt(n))개씩의 원소로 이루어진 그룹 O(sqrt(n))개로 나눌 수 있다.
    * O(n), Linear alg.. : 입력을 쭉 살펴보는 과정을 상수 번 수행한다. 대부분의 경우 가장 효율적인 시간복잡도
    * O(n*log(n)) : 입력을 정렬하는 과정의 시간복잡도(효율적인 정렬 알고리즘의 시간복잡도와 같음), 한번 수행할 때마다 O(log(n))시간이 걸리는, 자료구조를 사용하는 알고리즘
    * O(n^2), Quadratic alg.. : 2중 중첩 반복문. 이 시간동안 입력 원소 두개로 만들 수 있는 모든 조합을 한 번씩 살펴볼 수 있다.
    * O(n^3), Cubic alg.. : 3중 중첩 반복문, 이 시간동안 원소 세 개로 만들 수 있는 모든 조합(tiplet)을 한 번씩 살펴볼 수 있다.
    * O(2^n) : 입력원소로 만들 수 있는 모든 부분집합을 한 번씩 살펴볼 경우 자주 사용.
    * O(n!) : 입력원소로 만들 수 있는 모든 순열을 한 번씩 살펴볼 때 자주 사용한다. 

    * O(n^k)를 넘지 않는 경우 **다항 시간 알고리즘**이라고 한다. 위의 경우 2^n과 n!를 제외하곤 모두 다항 시간 알고리즘에 속한다.
    * **NP-hard problem**은 아직 다항 시간 알고리즘이 알려지지 않은 것들의 집합이다.

* 효율성 추정
* 현대의 컴퓨터는 초마다 수억개의 연산을 수행할 수 있다.
* 문제에 시간제한이 1초이며 입력의 크기가 n=10^5이라고 해보자
* 만일 시간복잡도가 O(n^2)이라면 알고리즘은 약 10^10번의 연산을 수행할 것이다. 이를 위해서는 적어도 수십초가 필요하다.
* 반면 시간복잡도가 O(nlog(n))이라면 연산횟수가 약 1.6 * 10^6 정도가 되고, 시간제한안에 들어오게 된다.
* 이와 같은 방법으로 입력의 크기를 이용하여 역으로 그 문제를 풀기에 적합한 알고리즘의 시간복잡도를 추정해 볼 수 있다.


### 4장
* 정렬 알고리즘
* 버블정렬(Bubble sort), 시간복잡도 : O(n^2)
    * 항상 배열에서 연달아 있는 원소만을 맞바꾸는 정렬 알고리즘
    * k번의 라운드가 끝나면 가장 큰 원소 k개가 올바른 위치에 놓이게 된다.
    ```
    for (int i=0; i < n; i++) {
        for (int j=0; j < n-1 j++) {
            if (array[j] > array[j+1]) {
                swap(array[j], arrau[j+1]);
            }
        }
    }
    ```
* 역위(Inversion) : 배열 인덱스의 조합 (a,b)가 'a < b'이지만 'array[a] > array[b]'를 만족할 때 이를 역위라 한다.
    * 즉, 원소의 순서가 잘못되었을 때를 의미한다.
    * 역위의 개수는 배열을 정렬하는데 필요한 작업량을 나타낸다.
    * 역위가 존재하지 않으면 해당 배열은 완전하게 정렬된 상태이며, 배열이 역순일 경우 역위의 개수는 (1+2+...+n-1) = (n(n-1))/2 = O(n^2)이다.
    * 연달아 있는 두 잘못된 순서의 원소들을 맞바꾸면 배열의 역위 개수가 하나 줄어든다. 즉, 정렬이 연달아 있는 원소만을 맞바꾼다면, 단계마다 역위 개수는 많아야 한 개만 줄어든다.
    * 따라서 알고리즘의 시간복잡도는 최소한O(n^2)이 된다.
* 병합 정렬(Merge sort), 시간복잡도 : O(nlog(n))
    * 병합정렬은 재귀를 이용하는 분할정복 알고리즘의 대표적이 예시다이다.
    * 부분 배열 array[a,...,b]를 정렬하는 병합정렬의 아이디어는 다음과 같다.
        1. a == b이면 아무것도 수행하지 않는다. a == b이면 부분배열은 원소한개로 이루어져 있으며, 이미 완전히 정렬된 상태이다.
        2. a, b사이 가운데 원소 k = (a+b)/2와 같이 계산한다. 소수점은 버린다.
        3. 재귀적으로 array[a,...,k]를 정렬한다.
        4. 재귀적으로 array[k+1,...,b]를 정렬한다.
        5. 정렬된 부분 배열 array[a,...,k]와 array[k+1,...,b]를 병합하여 정렬된 부분 배열 array[a,...,b]로 만든다.
    * 병합정렬이 효율적인 인유는 단계마다 부분 배열의 크기를 절반으로 줄여나가기 때문이다.
    * 그 후에 절렬된 부분 배열을 선형시간에 병합할 수 있는데, 이는 부분 배열이 이미 정렬되어 있기 때문이다.
    * 재귀 호출의 단계가 O(log(n))이고, 각 단계를 처리하는데 총 O(n)시간이 걸리기 때문에 전체 시간 복잡도는 O(nlog(n))이 된다.
* 정렬의 하한
    * 어떤 정렬 알고리즘이던, 배열의 원소를 비교하는데에 기반을 둔 정렬 알고리즘(Comparison sort)은 O(nlog(n))보다 빠를 수 없다.
    * 정렬을 두 원소를 비교함으로써 배열의 구성에 대한 정보를 얻어 나가는 과정이라 생각하면,
    * 배열의 두 원소를 비교하는 과정은 자식이 두개인 반복된 이진 트리형태로 그려지게 된다. 이것을 결정트리, decision tree라고 한다.
    * 정렬의 결과는 leaf node에 나타나며 갯수는 n!개이다.(정렬의 결과는 모든 순열, permutation에 해당하기 때문)
    * 어떤 이진트리의 leaf node가 n!개를 가지려면 그 트리의 높이는 log(n!)보다 낮을 수 없다.
    * log(n!)를 수학적으로 정리하면 log(n!) >= (n/2)*log(n/2)가 되므로 O(nlog(n))으로 나타낼 수 있다.
    * 따라서 어떤 Comparison sort던 시간복잡도는 O(nlog(n))보다 나을수 없다.
* 계수 정렬(Counting sort)
    * 계수 정렬은 배열의 원소를 직접 비교하지 않는데(non-comparison sort), 이러한 정렬에는 nlog(n)이라는 하한이 적용되지 않는다.
    * 배열의 모든 원소가 0...c 범위의 정수이며 c=O(n)일 때 O(n) 시간에 배열을 정렬하는 알고리즘이다.
    * 장부 배열을 만든다. 그리고 정렬할 배열의 각각의 원소가 배열에 몇 개씩 들어있는지 계산한다.
    * 원소값과 일치하는 인덱스에 그 수가 나타나는 갯수를 저장한다.
    * 예시
        1. 정렬할 배열이 주어진다. [1, 3, 6, 9, 9, 3, 5, 9]
        2. 가장 큰 원소가 9이므로 0부터 9의 범위를 갖는(크기가 10인) 배열을 생성한다. [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        3. 각 원소가 배열에 몇 개씩 들어있는지 계산하여 2.의 배열에 저장한다(장부 배열을 만든다). [0, 1, 0, 2, 0, 1, 1, 0, 0, 3]
    * 장부배열을 만드는데 O(n)시간이 걸린다. 그리고, 장부배열을 이용하여 정렬된 배열을 만드는데도 O(n)시간이 걸린다.
    * 따라서 계수 정렬의 전체 시간복잡도는 O(n)이다.
    * **계수정렬은 효율적이지만, 원래 배열의 원소를 장부배열의 인덱스로 사용할 수 있을 만큼 상수 c가 작을 때만 사용이 가능하다.**
* C++ 표준 라이브러리
    * C++에서는 정렬을 위해 STL로 sort() 함수를 지원한다. C++11 표준에 따르면 O(nlog(n))에 동작해야 한다고 규정하고 있다.
    * 아래는 sort() 함수를 이용해 정렬하는 몇 가지 예시를 보여준다.
        * vector 정렬
            ```
            vector<int> v = {4, 2, 5, 3, 5, 8, 3};
            sort(v.begin(), v.end());    // 오름차순
            sort(v.rbegin(), v.rend());  // 역순
            ```
        * 배열 정렬
            ```
            int n = 7;          // 배열의 크기
            int a[] = {4, 2, 5, 3, 5, 8, 3};
            sort(a, a+n);
            ```
        * 문자열 정렬
            ```
            string s = "monkey";
            sort(s.begin(), s.end());       // "ekmnoy"
            ```
    * 비교 연산자
        * sort 함수를 사용하기 위해서는 정렬할 원소의 자료형에 대해 비교연산자가 정의되어 있어야 한다.
        * 대부분의 C++ 자료형엔 내장되어 있다. 수는 값의 크기, 문자열은 알파벳 순으로 정렬하고
        * 두 원소의 조합(pair)과 여러 원소의 조합(tuple)은 먼저 첫번째 원소를 기준으로, 그 다음에는 두번째 원소를... 로 정렬한다.
        * 사용자 정의 구조체를 정렬하기 위해서는, 비교연산자(operator<)를 정의해줘야 한다.
        * 아래는 구조체 안에 함수 operator<를 정의하는 것을 보여준다.
            ```
            struct point {
                int x, y;
                bool operator<(const point &p) {
                    if (x == p.x) return y < p.y;
                    else return x < p.x;
                }
            }
            ```
        * 위 구조체를 원소로 갖는 배열, 벡터 등을 정렬하면 먼저 x값을 기준으로, 그 다음으로 y값을 기준으로 정렬한다.
    * **비교 함수**
        * 외부에 정의된 비교함수를 sort 함수에 콜백 함수 형태로 줄 수 있다.
        * 예를 들어 다음 비교함수 comp는 문자열을 먼저 길이순으로, 그 다음에는 알파벳순으로 정렬한다.
            ```
            bool comp(string a, stinrg b) {
                if (a.size() == b.size()) return a < b;
                else return a.size() < b.size();
            }
            ```
        * 위에서 정의한 비교함수로 문자열 벡터를 다음과 같이 정렬할 수 있다.
            ```
            sort(v.begin(), v.end(), comp);
            ```
* 정렬을 이용한 문제풀이
* 무차별 알고리즘으로 O(n^2)으로 풀수있는 문제를 O(n) 또는 O(nlog(n))으로 만드는 것이 자주 알고리즘 설계의 목표가 된다.
* 예를 들어 배열의 모든 원소가 유일한지 검사하는 문제가 있다.  
    * 무차별 알고리즘 O(n^2)
        ```
        bool ok = true;
        for (int i=0; i<n; i++) {
            for (int j=i+1; j<n; j++) {
                if (array[i] == array[j]) ok = false;
            }
        }
        ```
    * 정렬을 이용하면 O(nlog(n))에 풀 수 있다.
        ```
        bool ok = true;
        sort(array, array+n);       // n은 배열의 길이
        for (int i=0; i<n-1; i++) {
            if (array[i] == array[i+1]) ok = false;
        }
* 비슷한 문제로는 '서로 다른 원소의 개수를 세는 문제', '가장 빈번한 값을 구하는 문제', '차이가 가장 작은 두 원소를 구하는 문제' 등이 있다.
    * 스윕 라인 알고리즘, Sweep line algorithm
        * 


* 이진 탐색, binary search
* 정렬된 배열에 특정 원소가 존재하는 여부를 파악하는 등의 문제를 O(log(n)) 시간에 해결하는 알고리즘.
    * 이진 탐색 구현
        * 원소 n개가 정렬된 배열이 있을 때, 목표값 x가 포함되어 있는지 찾는다.
        1. 전통적인 방법
            * 처음에는배열 전체를 놓고 시작해서 단계별로 탐색범위를 전반씩 줄여나간다.
            * 단계마다 현재 탐색하고 있는 부분 배열 중앙의 원소를 검사한다.
            * 만일 중앙 원소가 목표값과 같다면 탐색을 끝낸다.
            * 중앙 원소가 x보다 크면 부분 배열의 왼쪽, 작으면 부분배열의 오른쪽 절반을 택하여 재귀적으로 탐색을 계속해 나간다.
                ```
                int a=0, b=n-1;
                while (a<=b) {
                    int k = (a+b)/2;
                    if (array[k] == x) {
                        // 위치 k에서 x를 찾음
                    }
                    if (array[k] < x) a = k+1;
                    else b = k-1;
                }
                ```
            * 해당 알고리즘은 단계마다 탐색하는 부분배열의 크기를 반씩 줄여나가므로 O(log(n))의 시간복잡도를 가진다.
        2. 탐색 방향을 정해놓는 방식
            * 또 다른 방법은 배열을 왼쪽에서 오른쪽으로 건너뛰며 탐색하는 것이다. 
            * 처음에는 n/2개의 원소를 건너뛴다. 라운드마다 건너뛸 원소 수를 n/4, n/8, n/16과 같은 식으로 절반 씩 줄여나가며 1이 될 때까지 진행한다.
            * 각 iteration에서 원소를 건너뛰는데, 배열의 범위를 벗어나거나 건너뛴 후의 원소가 목표 값을 벗어난다면 건너뛰지 않고 멈춘다.
            * 이처럼 진행하고 나면 찾고자 하는 원소에 도달하게 되고, 혹 그렇지 않다면 배열에 그 원소가 존재하지 않는다는 것을 알 수 있다.
                ```
                int k = 0;
                for (int b = n/2; b >= 1; b /= 2) {
                    while (k+b < n && array[k+b] <= x) k += b;
                }
                if (array[k] == x) {
                    // 위치 k에서 x를 찾음
                }
            * 탐색 과정에서 건너뛸 원소 수는 변수 b에 저장된다. 
            * 코드 안의 while 반복문이 같은 b에 대해 최대 두번만 수행되기 때문에 이 알고리즘도 O(log(n))이 된다.
    * 최적해 구하기
        * True, False를 반환하는 valid(x) 함수가 존재할 때, valid(x)가 x<k 일 때 false. x>=k 일 때 true라고 하자.
        * 이런 상황에서는 이진 탐색을 이용하여 효율적으로 k값을 구할 수 있다.
        * 우선 valid(x)가 false인 x의 최대값을 이진 탐색으로 구하면, valid(x)가 true인 k의 최솟값이 된다.
            ```
            int x = -1;
            for (int b=z; b>=1; b/=2) {
                while (!valid(x+b)) x += bl
            }
            int k = x+1;
            ```
        * 이 때, 처음에 건너뛸 원소의 개수 z는 답의 상한이 되어야 한다. 즉, valid(z)가 true임이 확실하다는 것이 보장되어야 한다.
        * 이 알고리즘은 valid() 함수를 O(log(z))번 호출하며, 따라서 전체 수행시간은 valid()의 수행시간에 달려있다.
        * ex) valid()의 수행시간이 O(n)이라면, 전체 수행시간은 O(nlog(z))이 된다.
        