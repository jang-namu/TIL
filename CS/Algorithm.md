## 알고리즘
알고리즘 트레이닝, 프로그래밍 대회 입문 가이드.

### 1장
* 경진 프로그래밍 = 알고리즘 설계 + 구현
* 요점 : 문제 해결 능력 향상과 간단한 도구를 이용하여 어려운 문제를 푸는 방법
* CSES 문제 셋 : [Code Submission Evaluation system](https://cses.fi/problemset)
* 코딩테스트 시, 알고리즘의 채점은 데이터셋의 입력에 대한 결과로 확인하기 때문에 알고리즘은 정확했다 해도 구현 시 문제가 발생할 수 있다.
* 예를 들어 수의 자료형을 int로 했을 경우, 입력 데이터셋의 연산결과가 int 자료형의 범위를 벗어난다면 예상치 못한 결과가 나올 수 있다. 

### 2장
* C++ 언어의 특성
    * C++ 코드 템플릿
        * #include <bits/stdc++.h> : 표준 라이브러리 전체를 포함시키는 g++컴파일러의 기능
        * g++ -std=c++11 -02 -Wall test.cpp -o test : 작성한 코드를 컴파일하는 명령어, test.cpp 를 컴파일해서 test 실행파일 생성
        * 컴파일러는 c++11 표준을 따르고 코드를 최적화하면(-02), 발생 가능한 오류에 대한 경고를 띄운다(-Wall)
    * 입력 데이터셋
        * 입력 데이터셋은 일반적으로 공백이나 개행문자로 구분된 문자열 및 수로 이뤄져있다.
        * c++에서는 이러한 입력을 'cin >> a >> b >> x;' 로 처리한다. 입력 원소 사이에 적어도 한개의 공백이나 개행문자가 존재할 경우 이런 형태의 코드는 항상 문제없이 작동한다.
            1. 123 456 example
            2. 123   456 
               example
        * 위 1, 2 모두에서 정상적으로 작동한다.
        
        * 공백을 포함한 채로, 입력한 줄을 통째로 읽어들이기 위해서 getline 함수를 사용한다
            1. string s;
            2. getline(cin, s);

        * 만일 데이터의 양을 사전에 알 수 없는 경우 아래와 같이 작성한다
            1. while (cin >> x) {}

    * 효율적인 입출력
        * 효율적인 출력을 위해선 endl 대신 '\n'을 사용하는 것이 좋다. endl을 사용할 경우 명시적인 플러시가 일어나기 때문에 개행문자를 사용하는 것이 빠르다.
        * 간혹 입출력이 프로그램의 병목이 될때면, 코드 시작 부분에 아래와 같은 코드를 추가해 입출력을 좀 더 효율적으로 할 수 있다.
            ```
            ios::sync_with_stdio(0);
            cin.tie(0);
            ```
        * 다만 이와 같은 경우 C언어 입출력함수(scanf, printf)를 C++ 입출력함수와 동시에 사용할 수 없다. (일반적으로 C언어의 입출력이 더 빠르다)
            ```
            int a, b;
            scanf("%d %d",&a,&b);
            printf("%d %d\n",a,b);
            ```

    * 대회, 입출력 파일 시스템
        * 몇몇 대회 시스템은 입출력을 위해 파일을 사용하기도 한다. 이를 간단하게 처리하기 위해 평소처럼 표준스트림을 사용하는 코드를 작성 후,
        * 아래 두 줄을 코드의 시작부분에 추가한다.
            ```
            freopen("input.txt", "r", stdin);
            freopen("output.txt", "w", stdout);
            ```

    * 부동소수점 실수의 정밀도
        * 몇몇 문제들은 출력에 대해 특정한 정밀도를 요구한다. 이에 맞춰 답을 출력하는 가장 간단한 방법은 printf 함수를 사용하고 형식문자열에 답의 소수점 아래 자릿수를 명시한다.
        * printf("%.9f\n", x); 소수점 아래 9자리까지만 출력한다.

* 수를 처리하는 방법
    * 정수자료형은 int를 기본으로, 부족하다면 'long long' 자료형을 쓴다.
        * long long x = 123456789123456789LL;    LL은 이 정수값의 자료형이 long long임을 의미한다.
        * 아래와 같은 코드는 예상치 못 한 결과를 초래한다
            1. int a = 123456789;
            2. long long b = a * a;
        * 문제를 해결하기 위해선 a의 자료형을 long long으로 바꾸거나, 계산식을 '(long long)a * a'로 수정한다.
        * 이 외에 g++ 컴파일러는 128비트 자료형인 __int128_t를 지원한다.

    * modulo 연산
        * 나머지 연산을 수행할 때 다음과 같은 공식이 성립한다
            * (a+b) mod m = (a mod m + b mod m) mod m
            * (a-b) mod m = (a mod m - b mod m) mod m
            * (a*b) mod m = (a mod m * b mod m) mod m
        * 음수의 나머지를 구하는 경우, 나머지 연산 수행후에 결과에 m을 더해준다.

    * 부동 소수점 실수
        * 일반적으로 64bit, double을 많이 사용하고 g++ 컴파일러가 지원하는 확장 자료형인 80bit, long double도 유용하다.
        * 다만 부동소수점을 사용할 때 어려운 점은 부동소수점수는 정확하게 표현이 안 된다는 점이다.
        * 따라서 부동 소수점 실수를 비교할 때에는 '=='연사자를 사용하기보다 두 수의 차이가 입실론보다 작을 때 일치한다고 판단하는 것이 더 나은 방법이다.
        * 부동 소수점 실수는 일반적으로 부정확하지만 특정 범위까지의 정수는 정확하게 표현 가능하다. 예로 double의 경우 절대값이 2^53 이하인 모든 정수를 정확하게 표현가능하다.

* 코드 짧게 만들기
    * typedef을 통해 자료형의 이름을 짧게 만들 수 있다.
        1. typedef long long ll;
        2. ll a = 123456789LL;
    * 이 외에도 vector<>, pair<,> 등의 자료형에도 사용할 수 있다.
 
* 매크로(macro) 이용
    * 매크로는 코드를 컴파일하기 전에 코드에 포함된 특정 문자열을 다른 문자열로 치환하는 규칙이다.
    * #define 지시문을 통해 매크로를 정의할 수 있다.
        1. #define F first
        2. #define S second
    * 매크로를 이용하면 자주 사용되는 메소드나 변수의 이름 등을 간략화 할 수 있다.
    * 아래와 같은 방법으로 매크로에 인자를 줄수도 있다.
        1. #define REP(i,a,b) for (int i = a; i <= b; i++)

* 재귀(Recursion)적 알고리즘
    * 부분집합 생성하기
    * 순열 생성하기
    * 퇴각 검색(Backtracking)

* 비트 연산
    * C++의 int는 부호비트가 존재하는 자료형이다. 따라서 32비트인 int는 -2^31 ~ 2^31-1 까지의 수를 표현 가능하다.
    * 또한 이런 자료형은 2의 보수 표현법을 사용한다.
    * C++에서는 부호가 없는 정수표현도 제공한다. unsigned int는 0부터 2^32-1가지의 값을 가질 수 있다.
    * 수의 표현 방법에 따라 다음의 예제가 성립한다
        1. int x = -43;  **x = -43**
        2. unsigned int y = x;  **'y = 4294967253' == 2^32 - 43**
    
    * AND(&) 연산
        * And 연산을 이용하면 어떤 정수 x가 홀수인지 짝수인지 알 수 있다. 짝수이면 x & 1 = 0, 홀수이면 x & 1 = 1이다.
        * 이를 일반화해서 x가 2^k로 나누어떨어지는 경우는 x & 2^k-1 = 0 일 때이다.
    * OR(|), XOR(^)
    * NOT(~) 연산
        * ~x = -x-1임이 성립한다.
    * 비트 시프트 연산 (<<), (>>)
        * 좌측 시프트 연산 'x<<k' 는 정수의 오른쪽에 비트 0을 k개 덧붙이고, 우측 시프트 연산 'x>>k'는 정수의 오른쪽 비트 k개를 제거하는 연산이다.
        * 각각 x에 2^k를 곱한것과 x를 2^k로 나눈 후 정수로 내림한 것과 같다.
        * 주의할 점. 비트 시프트 연산의 결과는 항상 int형이다. '1LL<<k'와 같은 방법으로 long long형 정수에 비트 연산을 할 수 있다.
    
    * g++ 컴파일가 제공하는 기능
        * __builtin_clz(x) : 왼쪽끝부터 연속해서 있는 비트 0의 개수
        * __builtin_ctz(x) : 오른쪽끝부터 연속해서 있는 비트 0의 개수
        * __builtin_popcount(x) : 비트 1의 개수
        * __builtin_parity(x) : 비트 1에 대한 패리티 (1이면 홀수)
        * int형만 지원되며, 함수이름 뒤에 ll을 덧붙이면 long long형 정수를 지원하는 함수가 된다.
    
    * 집합 표현
        * 집합 {0,1,2,...,n-1}의 모든 부분지합을 n비트 정수를 이용하여 표현할 수 있다.
        * 예를 들어 int형 정수는 32bit이므로 {0,1,...,31}의 모든 부분집합을 표현 가능하다.
        * 집합 {1,3,4,8}의 경우 00000000000000000000000100011010로 나타낸다. 이에 대응되는 정수는 282이다.
            ```
            int x=0;
            x |= (1<<1);
            x |= (1<<3);
            x |= (1<<4);
            x |= (1<<8);
            cout << __builtin_popcount(x);   // 4
            ```
        * 집합에 대한연산 또한 비트연산으로 구현할 수 있다.
            * 합집합은 두 집합의 '|'연산으로 표현할 수 있다.
            * 교집합은 '&'연산을 수행한 것과 같다.
            * 여집합은 '~'연산과 같다.
            * 차집합은 'a&(~b)'를 수행한 것과 같다.
        
        * 비트셋(bitset) 자료구조
            * C++ 표준 라이브러리에서 제공하는 자료구조
            * 원소가 0또는 1인 배열로 쓸 수 있다.
            * count() 함수는 비트셋에 포함된 비트 1의 개수를 반환한다.
            * 비트연산을 비트셋에 대해 그대로 적용할 수 있다.


### 3장.효율성
* 시간복잡도 
    * 시간복잡도는 알고리즘의 효율성을 근사적으로 측정하는 도구
    * 입력 n에 대한 시간 복잡도를 O(...)형식으로 괄호안에는 n에대한 함수로 표현.
* 계산규칙
    * 빅오를 이용해 시간복잡도를 표현할 떄에는, 함수의 차수만을 생각한다.
    * 알고리즘이 여러 단계로 구성되면, 전체시간복잡도는 시간복잡도 중 제일 큰 것이 된다.
    * 가장 느린 단계가 알고리즘의 병목이 되기 때문이다.
    * 시간복잡도가 여러 인자에 영향을 받으면 시간 복잡도 함수에 여러 변수가 포함될 수 있다. ex) O(mn)
    * 재귀함수의 시간복잡도는 함수가 몇 번 호출되는지, 각 호출 때 시간 복잡도가 어떻게 되는지에 따라 결정된다.
    * 재귀함수의 전체시간복잡도는 이 둘을 곱합 형태가 된다.
* 자주 접할 수 있는 시간복잡도
    * O(1), Constant time algorithm : 입력에 크기에 영향X, ex) 공식을 이용해 답을 바로 계산
    * O(log(n)), Logarithmic algorithm : 단계마다 입력의 크기를 절반씩 줄여나간다. 로그의 밑수가 시간 복잡도에 나타나 있지않다.
    * O(sqrt(n)), Square root alg.. : 제곱근의 성질 'sqrt(n) = n/sqrt(n)'. 따라서 n개의 원소를 각각 O(sqrt(n))개씩의 원소로 이루어진 그룹 O(sqrt(n))개로 나눌 수 있다.
    * O(n), Linear alg.. : 입력을 쭉 살펴보는 과정을 상수 번 수행한다. 대부분의 경우 가장 효율적인 시간복잡도
    * O(n*log(n)) : 입력을 정렬하는 과정의 시간복잡도(효율적인 정렬 알고리즘의 시간복잡도와 같음), 한번 수행할 때마다 O(log(n))시간이 걸리는, 자료구조를 사용하는 알고리즘
    * O(n^2), Quadratic alg.. : 2중 중첩 반복문. 이 시간동안 입력 원소 두개로 만들 수 있는 모든 조합을 한 번씩 살펴볼 수 있다.
    * O(n^3), Cubic alg.. : 3중 중첩 반복문, 이 시간동안 원소 세 개로 만들 수 있는 모든 조합(tiplet)을 한 번씩 살펴볼 수 있다.
    * O(2^n) : 입력원소로 만들 수 있는 모든 부분집합을 한 번씩 살펴볼 경우 자주 사용.
    * O(n!) : 입력원소로 만들 수 있는 모든 순열을 한 번씩 살펴볼 때 자주 사용한다. 

    * O(n^k)를 넘지 않는 경우 **다항 시간 알고리즘**이라고 한다. 위의 경우 2^n과 n!를 제외하곤 모두 다항 시간 알고리즘에 속한다.
    * **NP-hard problem**은 아직 다항 시간 알고리즘이 알려지지 않은 것들의 집합이다.

* 효율성 추정
* 현대의 컴퓨터는 초마다 수억개의 연산을 수행할 수 있다.
* 문제에 시간제한이 1초이며 입력의 크기가 n=10^5이라고 해보자
* 만일 시간복잡도가 O(n^2)이라면 알고리즘은 약 10^10번의 연산을 수행할 것이다. 이를 위해서는 적어도 수십초가 필요하다.
* 반면 시간복잡도가 O(nlog(n))이라면 연산횟수가 약 1.6 * 10^6 정도가 되고, 시간제한안에 들어오게 된다.
* 이와 같은 방법으로 입력의 크기를 이용하여 역으로 그 문제를 풀기에 적합한 알고리즘의 시간복잡도를 추정해 볼 수 있다.


### 4장
* 정렬 알고리즘
* 버블정렬(Bubble sort), 시간복잡도 : O(n^2)
    * 항상 배열에서 연달아 있는 원소만을 맞바꾸는 정렬 알고리즘
    * k번의 라운드가 끝나면 가장 큰 원소 k개가 올바른 위치에 놓이게 된다.
    ```
    for (int i=0; i < n; i++) {
        for (int j=0; j < n-1 j++) {
            if (array[j] > array[j+1]) {
                swap(array[j], arrau[j+1]);
            }
        }
    }
    ```
* 역위(Inversion) : 배열 인덱스의 조합 (a,b)가 'a < b'이지만 'array[a] > array[b]'를 만족할 때 이를 역위라 한다.
    * 즉, 원소의 순서가 잘못되었을 때를 의미한다.
    * 역위의 개수는 배열을 정렬하는데 필요한 작업량을 나타낸다.
    * 역위가 존재하지 않으면 해당 배열은 완전하게 정렬된 상태이며, 배열이 역순일 경우 역위의 개수는 (1+2+...+n-1) = (n(n-1))/2 = O(n^2)이다.
    * 연달아 있는 두 잘못된 순서의 원소들을 맞바꾸면 배열의 역위 개수가 하나 줄어든다. 즉, 정렬이 연달아 있는 원소만을 맞바꾼다면, 단계마다 역위 개수는 많아야 한 개만 줄어든다.
    * 따라서 알고리즘의 시간복잡도는 최소한O(n^2)이 된다.
* 병합 정렬(Merge sort), 시간복잡도 : O(nlog(n))
    * 병합정렬은 재귀를 이용하는 분할정복 알고리즘의 대표적이 예시다이다.
    * 부분 배열 array[a,...,b]를 정렬하는 병합정렬의 아이디어는 다음과 같다.
        1. a == b이면 아무것도 수행하지 않는다. a == b이면 부분배열은 원소한개로 이루어져 있으며, 이미 완전히 정렬된 상태이다.
        2. a, b사이 가운데 원소 k = (a+b)/2와 같이 계산한다. 소수점은 버린다.
        3. 재귀적으로 array[a,...,k]를 정렬한다.
        4. 재귀적으로 array[k+1,...,b]를 정렬한다.
        5. 정렬된 부분 배열 array[a,...,k]와 array[k+1,...,b]를 병합하여 정렬된 부분 배열 array[a,...,b]로 만든다.
    * 병합정렬이 효율적인 인유는 단계마다 부분 배열의 크기를 절반으로 줄여나가기 때문이다.
    * 그 후에 절렬된 부분 배열을 선형시간에 병합할 수 있는데, 이는 부분 배열이 이미 정렬되어 있기 때문이다.
    * 재귀 호출의 단계가 O(log(n))이고, 각 단계를 처리하는데 총 O(n)시간이 걸리기 때문에 전체 시간 복잡도는 O(nlog(n))이 된다.
* 정렬의 하한
    * 어떤 정렬 알고리즘이던, 배열의 원소를 비교하는데에 기반을 둔 정렬 알고리즘(Comparison sort)은 O(nlog(n))보다 빠를 수 없다.
    * 정렬을 두 원소를 비교함으로써 배열의 구성에 대한 정보를 얻어 나가는 과정이라 생각하면,
    * 배열의 두 원소를 비교하는 과정은 자식이 두개인 반복된 이진 트리형태로 그려지게 된다. 이것을 결정트리, decision tree라고 한다.
    * 정렬의 결과는 leaf node에 나타나며 갯수는 n!개이다.(정렬의 결과는 모든 순열, permutation에 해당하기 때문)
    * 어떤 이진트리의 leaf node가 n!개를 가지려면 그 트리의 높이는 log(n!)보다 낮을 수 없다.
    * log(n!)를 수학적으로 정리하면 log(n!) >= (n/2)*log(n/2)가 되므로 O(nlog(n))으로 나타낼 수 있다.
    * 따라서 어떤 Comparison sort던 시간복잡도는 O(nlog(n))보다 나을수 없다.
* 계수 정렬(Counting sort)
    * 계수 정렬은 배열의 원소를 직접 비교하지 않는데(non-comparison sort), 이러한 정렬에는 nlog(n)이라는 하한이 적용되지 않는다.
    * 배열의 모든 원소가 0...c 범위의 정수이며 c=O(n)일 때 O(n) 시간에 배열을 정렬하는 알고리즘이다.
    * 장부 배열을 만든다. 그리고 정렬할 배열의 각각의 원소가 배열에 몇 개씩 들어있는지 계산한다.
    * 원소값과 일치하는 인덱스에 그 수가 나타나는 갯수를 저장한다.
    * 예시
        1. 정렬할 배열이 주어진다. [1, 3, 6, 9, 9, 3, 5, 9]
        2. 가장 큰 원소가 9이므로 0부터 9의 범위를 갖는(크기가 10인) 배열을 생성한다. [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        3. 각 원소가 배열에 몇 개씩 들어있는지 계산하여 2.의 배열에 저장한다(장부 배열을 만든다). [0, 1, 0, 2, 0, 1, 1, 0, 0, 3]
    * 장부배열을 만드는데 O(n)시간이 걸린다. 그리고, 장부배열을 이용하여 정렬된 배열을 만드는데도 O(n)시간이 걸린다.
    * 따라서 계수 정렬의 전체 시간복잡도는 O(n)이다.
    * **계수정렬은 효율적이지만, 원래 배열의 원소를 장부배열의 인덱스로 사용할 수 있을 만큼 상수 c가 작을 때만 사용이 가능하다.**
* C++ 표준 라이브러리
    * C++에서는 정렬을 위해 STL로 sort() 함수를 지원한다. C++11 표준에 따르면 O(nlog(n))에 동작해야 한다고 규정하고 있다.
    * 아래는 sort() 함수를 이용해 정렬하는 몇 가지 예시를 보여준다.
        * vector 정렬
            ```
            vector<int> v = {4, 2, 5, 3, 5, 8, 3};
            sort(v.begin(), v.end());    // 오름차순
            sort(v.rbegin(), v.rend());  // 역순
            ```
        * 배열 정렬
            ```
            int n = 7;          // 배열의 크기
            int a[] = {4, 2, 5, 3, 5, 8, 3};
            sort(a, a+n);
            ```
        * 문자열 정렬
            ```
            string s = "monkey";
            sort(s.begin(), s.end());       // "ekmnoy"
            ```
    * 비교 연산자
        * sort 함수를 사용하기 위해서는 정렬할 원소의 자료형에 대해 비교연산자가 정의되어 있어야 한다.
        * 대부분의 C++ 자료형엔 내장되어 있다. 수는 값의 크기, 문자열은 알파벳 순으로 정렬하고
        * 두 원소의 조합(pair)과 여러 원소의 조합(tuple)은 먼저 첫번째 원소를 기준으로, 그 다음에는 두번째 원소를... 로 정렬한다.
        * 사용자 정의 구조체를 정렬하기 위해서는, 비교연산자(operator<)를 정의해줘야 한다.
        * 아래는 구조체 안에 함수 operator<를 정의하는 것을 보여준다.
            ```
            struct point {
                int x, y;
                bool operator<(const point &p) {
                    if (x == p.x) return y < p.y;
                    else return x < p.x;
                }
            }
            ```
        * 위 구조체를 원소로 갖는 배열, 벡터 등을 정렬하면 먼저 x값을 기준으로, 그 다음으로 y값을 기준으로 정렬한다.
    * **비교 함수**
        * 외부에 정의된 비교함수를 sort 함수에 콜백 함수 형태로 줄 수 있다.
        * 예를 들어 다음 비교함수 comp는 문자열을 먼저 길이순으로, 그 다음에는 알파벳순으로 정렬한다.
            ```
            bool comp(string a, stinrg b) {
                if (a.size() == b.size()) return a < b;
                else return a.size() < b.size();
            }
            ```
        * 위에서 정의한 비교함수로 문자열 벡터를 다음과 같이 정렬할 수 있다.
            ```
            sort(v.begin(), v.end(), comp);
            ```
* 정렬을 이용한 문제풀이
* 무차별 알고리즘으로 O(n^2)으로 풀수있는 문제를 O(n) 또는 O(nlog(n))으로 만드는 것이 자주 알고리즘 설계의 목표가 된다.
* 예를 들어 배열의 모든 원소가 유일한지 검사하는 문제가 있다.  
    * 무차별 알고리즘 O(n^2)
        ```
        bool ok = true;
        for (int i=0; i<n; i++) {
            for (int j=i+1; j<n; j++) {
                if (array[i] == array[j]) ok = false;
            }
        }
        ```
    * 정렬을 이용하면 O(nlog(n))에 풀 수 있다.
        ```
        bool ok = true;
        sort(array, array+n);       // n은 배열의 길이
        for (int i=0; i<n-1; i++) {
            if (array[i] == array[i+1]) ok = false;
        }
    * 비슷한 문제로는 '서로 다른 원소의 개수를 세는 문제', '가장 빈번한 값을 구하는 문제', '차이가 가장 작은 두 원소를 구하는 문제' 등이 있다.
* 스윕 라인 알고리즘, Sweep line algorithm
    * 정렬된 순서대로 처리되는, 이벤트의 집합으로 문제를 모델링하는 방법
    * 여기서 이벤트는 문제를 푸는 아이디어 또는 입력이 되는 것을 말한다.
* 이벤트 스케줄링
    * 입력 데이터를 정렬한 후, 탐욕법 기반의 전략으로 해를 구하여 풀 수 있는 스케줄링 문제가 여럿있다.
    * 탐욕법(greedy strategy) : 현재 상황에서 최선으로 보이는 선택을 하며, 한번 선택한 것을 되돌리지 않는 방식.
    * 이벤트 n개의 시작 시각과 종료 시각이 주어질 때, 최대한 많은 수의 이벤트를 포함하는 스케줄을 구하는 문제
    * => 가능한 경우의 수를 생각해보면 결국 종료시각 기준으로 정렬한 후 가장 먼저 종료하는 것을 차례로 선택하는 것이 최적해를 구할 수 있는 방법이다.
* 작업과 데드라인
    * 작업 n개의 소요시간과 데드라인이 주어질 때, 작업의 순서를 결정하려 한다.
    * 작업의 데드라인이 d이고 작업 완료 시점의 시간이 x라면, 그 작업에 대해 d-x점의 점수를 얻는다. 최대점수는 얼마일까
    * 이 문제의 핵심은 최종 점수가 데드라인에 영향을 받지 않는 다는 것이다. 데드라인은 항상 고정적이기 때문이다.
    * 따라서 -x의 합을 최소화해야 한다. 이는 작업의 소요시간이 짧은 순으로 스케줄링하여 해결할 수 있다.
        * 작업 X, Y의 소요시간이 각각 a, b이고 a > b일 경우 X, Y의 순서를 바꿀 경우 X에 대해서는 b점만큼 잃지만, Y에 대해 a점을 더 얻게된다.
        * 따라서 최종 점수는 a-b>0만큼 증가하게 된다. 


* 이진 탐색, binary search
* 정렬된 배열에 특정 원소가 존재하는 여부를 파악하는 등의 문제를 O(log(n)) 시간에 해결하는 알고리즘.
    * 이진 탐색 구현
        * 원소 n개가 정렬된 배열이 있을 때, 목표값 x가 포함되어 있는지 찾는다.
        1. 전통적인 방법
            * 처음에는배열 전체를 놓고 시작해서 단계별로 탐색범위를 전반씩 줄여나간다.
            * 단계마다 현재 탐색하고 있는 부분 배열 중앙의 원소를 검사한다.
            * 만일 중앙 원소가 목표값과 같다면 탐색을 끝낸다.
            * 중앙 원소가 x보다 크면 부분 배열의 왼쪽, 작으면 부분배열의 오른쪽 절반을 택하여 재귀적으로 탐색을 계속해 나간다.
                ```
                int a=0, b=n-1;
                while (a<=b) {
                    int k = (a+b)/2;
                    if (array[k] == x) {
                        // 위치 k에서 x를 찾음
                    }
                    if (array[k] < x) a = k+1;
                    else b = k-1;
                }
                ```
            * 해당 알고리즘은 단계마다 탐색하는 부분배열의 크기를 반씩 줄여나가므로 O(log(n))의 시간복잡도를 가진다.
        2. 탐색 방향을 정해놓는 방식
            * 또 다른 방법은 배열을 왼쪽에서 오른쪽으로 건너뛰며 탐색하는 것이다. 
            * 처음에는 n/2개의 원소를 건너뛴다. 라운드마다 건너뛸 원소 수를 n/4, n/8, n/16과 같은 식으로 절반 씩 줄여나가며 1이 될 때까지 진행한다.
            * 각 iteration에서 원소를 건너뛰는데, 배열의 범위를 벗어나거나 건너뛴 후의 원소가 목표 값을 벗어난다면 건너뛰지 않고 멈춘다.
            * 이처럼 진행하고 나면 찾고자 하는 원소에 도달하게 되고, 혹 그렇지 않다면 배열에 그 원소가 존재하지 않는다는 것을 알 수 있다.
                ```
                int k = 0;
                for (int b = n/2; b >= 1; b /= 2) {
                    while (k+b < n && array[k+b] <= x) k += b;
                }
                if (array[k] == x) {
                    // 위치 k에서 x를 찾음
                }
            * 탐색 과정에서 건너뛸 원소 수는 변수 b에 저장된다. 
            * 코드 안의 while 반복문이 같은 b에 대해 최대 두번만 수행되기 때문에 이 알고리즘도 O(log(n))이 된다.
    * 최적해 구하기
        * True, False를 반환하는 valid(x) 함수가 존재할 때, valid(x)가 x<k 일 때 false. x>=k 일 때 true라고 하자.
        * 이런 상황에서는 이진 탐색을 이용하여 효율적으로 k값을 구할 수 있다.
        * 우선 valid(x)가 false인 x의 최대값을 이진 탐색으로 구하면, valid(x)가 true인 k의 최솟값이 된다.
            ```
            int x = -1;
            for (int b=z; b>=1; b/=2) {
                while (!valid(x+b)) x += bl
            }
            int k = x+1;
            ```
        * 이 때, 처음에 건너뛸 원소의 개수 z는 답의 상한이 되어야 한다. 즉, valid(z)가 true임이 확실하다는 것이 보장되어야 한다.
        * 이 알고리즘은 valid() 함수를 O(log(z))번 호출하며, 따라서 전체 수행시간은 valid()의 수행시간에 달려있다.
        * ex) valid()의 수행시간이 O(n)이라면, 전체 수행시간은 O(nlog(z))이 된다.


## 5장.자료구조
* 5.1 동적배열
    * 벡터(Vector)는 원소를 마지막에 추가하거나 삭제하는 과정을 효율적으로 할 수 있는 동적 배열이다.
        * 대개의 경우, 벡터와 배열의 속도는 거의 같으며 push_back, pop_back 함수는 평균 O(1) 시간에 동작한다.
        ```
        vector<int> v;
        v.push_back(3);
        cout << v[0]    // 3
        
        vector<int> a(8);   // 크기 8, 초기값 0
        vector<int> b(2, 2) // 크기 2, 초기값 2

        for (const auto& x : v) {       or      for (auto x : v)    // 전자가 빠르다. 후자는 복사, 전자는 참조복사
            cout << x << "\n";
        }

        v.size()   // 사이즈 
        v.back()   // 마지막 원소 반환
        v.pop_back()    // 마지막 원소 삭제
        ```
    * 반복자, Iterator
        * 자료구조의 원소를 가리키는 변수. begin() 반복자, end() 반복자 등..
        * begin() : 첫번째 원소, **end() : 마지막 원소 다음**을 가리킨다.
            * 반복자의 사용. C++은 함수는 범위를 사용하는 경우가 많음
                ```
                sort(v.begin(), v.end());
                reverse(v.begin(), v.end());
                random_shuffle(v.begin(), v.end());     // 원소를 뒤섞음
                ```
            * 반복자는 포인터이므로 '*'를 이용해 해당 원소에 접근할 수 있다.
    * 덱, deque
    * 양쪽 끝 원소를 효율적으로 처리할 수 있는 동적배열
        * 덱에 대한 연산도 평균 O(1) 시간이 걸린다.
        * 하지만 덱은 벡터보다 실행 시간의 상수항이 크기 때문에, 양쪽에서의 추가 또는 삭제가 필요할 때만 쓴다.
        * push_back(), pop_back()은 물론 push_front(), pop_front()도 지원
    * 스택, Stack
        * 끝에서 원소를 넣고 빼는 push(), pop(), 마지막원소를 반환하는 top()을 제공하는, 덱을 기반으로한 자료구조
    * 큐 , Queue
        * 원소 추가는 마지막에서, 삭제는 앞에서부터 이뤄지는 선인선출의 자료형
        * push(), pop()은 물론 그냥 반환만 하는 front()와 back()도 지원한다.
* 5.2 집합 자료구조
    * Set
        * 원소의 집합을 관리하는 자료구조. 원소추가, 탐색, 삭제 연산이 효율적으로 구현되어 있다.
        * set은 균형잡힌 이진 탐색 트리를 기반으로 만들어졌다. 연산은 O(log(n))시간에 동작한다.
        * unordered_set은 해시테이블 기반으로 만들어졌다. 연산은 평균적으로 O(1)시간에 동작한다.
        * set은 정렬되 있고, unoreder_set은 그렇지 않다.
            ```
            set<int> s;
            s.insert(3);
            cout << s.count(3); // 1
            s.erase(3);
            cout << s.count(3); // 0
            ``` 
        * set의 중요한 성질 **모든 원소가 서로 다르다.** 즉, count 함수가 반환하는 값은 무조건 0 이거나 1이다. 
        * 따라서 insert함수는 추가하려는 원소가 이미 있는 겨웅에는 원소를 추가하지 않는다.
            ```
            set<int> s;
            s.insert(3);
            s.insert(3);
            s.insert(3);
            cout << s.count(3); //1
            ```
        * 셋은 순서가 없기 때문에 인덱스로 원소에 접근할 수 없다.
    * 멀티셋, Multiset
        * 값을 여러개 가질 수 있는 집합. mulitiset과 unordered_multiset이 존재한다.
            ```
            mulitiset<int> s;
            s.insert(5);
            s.insert(5);
            s.insert(5);
            cout << s.count(5); // 3
            
            s.erase(5);
            cout << s.count(5); // 0
            // s.erase(s.find(5)); 와 같은 방식으로 원소를 한번에 하나만 지울 수 있다.
            ```
        * count 함수와 erase 함수의 복잡도에는 O(k) 항이 추가로 들어가며, k는 원소의 개수를 의미한다.
        * count 함수를 이용하여 개수를 구하는 것은 효율적이지 않다.
    * 맵, Map
        * map은 key와 value의 쌍을 저장하는 집합이다. 
        * 배열을 key가 0부터 n-1까지(인덱스)의 연속된 정수라고 본다면, map은 key값의 형태를 일반화한 형태라고 볼 수 있다.
        * map,과 unordered_map이 존재하며 각각 균형잡힌 이진탐색트리, 해시를 이용하여 O(log(n)), O(1) 시간이 걸린다.
            * 맵에 저장된 모든 키와 값을 출력하는 코드. m은 맵 자료구조이다.
            ```
            for (auto x : m) {
                cout << x.first << x.second;
            }
            ```
    * 우선순위 큐, Priority Queue
        * 원소의 추가, 탐색, 삭제 연산이 있는 멀티셋을 말한다.
        * 탐색 및 삭제의 대상이 되는 원소는 최소, 또는 최대 원소이며 둘 중 어느 것을 선택할지는 큐의 속성에 달려있다.
        * 원소의 추가, 삭제는 O(log(n)) 시간이 걸리며, 탐색은 O(1) 시간이 걸린다.
        * 일반적으로 우선순위 큐는 힙(heap)을 기반으로 만들어진다. heap이란 특별한 형태의 이진트리이다.
        * multiset이 우선순위 큐의 모든 연산을 포함하지만, 우선순위 큐가 더 빠르다.
        * 따라서, 최대 또는 최소 원소를 빨리 구하는 것이 목적이라면 우선순위 큐를 사용하는 것이 더 좋다.
        * C++ 우선순위 큐는 원소가 내림차순으로 정렬되어 있으며, 탐색 및 삭제의 대상이 되는 것은 최대 원소이다.
* 5.3 실험
    * 집합과 정렬
        * 집합이나 정렬을 이용해 문제를 풀 떄, **대부분의 경우 정렬을 이용한 알고리즘이 집합보다 훨씬 빠르다.**
        * 두 방법 모두 O(nlog(n))의 시간복잡도를 갖지만, set의 이진탐색트리가 정렬 알고리즘에 비해 복잡하기 때문이다.
    * 맵과 배열
        * 맵과 배열모두 O(1) 시간에 원소*에 접근하지만, 맵의 상수항이 크기때문에 **배열을 사용하는 것이 훨씬 빠르다.**
    * 우선순위 큐와 멀티셋
        * 마찬가지로 기능이 푸부한 멀티셋 보다 좀 더 단순한 **우선순위 큐를 사용하는 것이 빠르다.**


## 6장. 동적 계획법
* Dynamic programming은 문제의 최적해를 구하거나 답의 개수를 세는 과정에 사용할 수 있는 알고리즘 설계 기법이다.
* 6.1 기본 개념
    * 동전 교환 문제를 통해 탐욕법이 실패하는 경우를 알아보고, 동적 계획법을 이욯해 항상 최적의 답을 구하는 알고리즘을 알아본다.
    * 동전 교환 문제 : 여러 동전의 값 coins = {c1, c2, ... , ck}와 목표 액수 n이 주어진다. 
    * 최소한의 동전 수를 사용해서 합이 n이 되도록 만들어야 한다. 각 동전을 얼마나 쓸 수 있는지는 제한이 없다.
    * 예를 들어 coins = {1, 2, 5}이고 n = 12일 때, 최적해는 동전을 세 개 사용하여 5+5+2=12를 만드는 것이다.
        * 1) 탐욕법이 실패하는 경우
            * 탐욕법 : 항상 액수가 제일 큰 동전을 선택하되, 합이 목표 액수를 넘지 않도록 한다.
            * 실패 => coins = {1, 3, 4}이고 n=6인 경우, 최적해는 3+3=6으로 두 개 사용, 
            * but 탐욕 알고리즘은 4+1+1=6으로 세 개 사용하는 결과가 나온다.
        * 일반적인 탐욕법으론 실패 => 모든 경우의 수를 따지는 무차별 알고리즘
        * 무차별 알고리즘은 항상 최적해가 나오지만, 입력의 크기가 커지면 너무 느려진다.
        * 동적 계획법을 이용하면 무차별 알고리즘과 흡사하게 동작하면서 효율적으로 작성 가능.
        * 정확하며, 큰 입력을 처리할 수 있고 그 뿐만 아니라, 다른 여러 문제에도 적용 가능하다.
        * 2) 동적 계획법으로 최적해 구하기
            * 동적 계획법을 위해서는 **문제의 재귀적인 구조를 찾아야 함. => 작은 문제의 답을 이용하여 원래의 답을 계산.**
            * 위 동전 문제를 풀기 위해 합 x를 만들기 위한 동전의 최소개수를 의미하는 함수 solve(x)의 값을 구한다.
                * coins = {1, 3, 4}인 경우 solve(x)는
                * solve(0)=0, solve(1)=1, solve(2)=2, solve(3)=3, solve(4)=4, solve(5)=5
                * solve(6)=6, solve(7)=7, solve(8)=8. solve(9)=9, solve(10)=10
            * solve함수의 특징은 작은 함숫값을 이용해 큰 함숫값을 재귀적으로 구할 수 있다는 점이다.
            * 이 아이디어의 핵심은 첫 번째로 어떤 동전은 선택하는지의 초점을 맞추는 것이다.
            * n=10인 경우, 첫번쨰로 선택할 수 있는 동전의 값은 1, 3, 4 중 하나이다.
            * 만약 1을 선택한다면 남은 일은 합 9를 만드는 일이 되고 이는 원래 문제의 부분문제가 된다.
            * 따라서 다음과 같은 점화식이 성립한다. 'solve(x)=min(solve(x-1)+1, solve(x-3)+1, solve(x-4)+1)
            * 이 재귀함수의 기저조건은 solve(0)=0이다. 합을 0으로 만들기 위해서는 동전이 필요하지 않다.
            * 예를 들면 solve(10) = solve(7)+1 = solve(4)+2 = solve(0)+3 = 3
                ```
                int solve(int x) {
                    if (x<0) return infinity;
                    if (x == 0) return 0;
                    int best = infinity;
                    for (auto c : coins) {
                        best = min(best, solve(x-c)+1);
                    }
                    return best;
                }
                ```
            * 이를 C++ 코드로 짜면 위와 같은 코드가 되는데, **경우를 모두 계산하며 살펴보기 때문에 이런 함수는 효율적이지 않다.**
            * 이를 개선하여 효율적은 함수를 만든다.
        * 메모이제이션(memoization)
            * 메모이제이션은 동적 계획법에서 아주 중요한 개념으로 **함수의 값을 계산한 뒤 이를 배열에 저장하는 방법을 말한다.**
            * 저장해둔 값이 다시 필요할 때마다 함수를 새로 호출하지 않고 값을 가져올 수 있게된다.
                ```
                bool ready[N];  // solve(x)의 값이 계산되었는지를 의미한다.
                int value[N];   // 계산된 값을 저정한다. N은 필요한 모든 값이 배열 범위 안에 저장될 수 있도록 충분한 크기여야 한다.
                int solve(int x) {
                    if (x<0) return infinity;
                    if (x == 0) return 0;
                    if (ready[x]) return value[x]
                    int best = infinity;
                    for (auto c : coins) {
                        best = min(best, solve(x-c)+1);
                    }
                    ready[x] = true;
                    value[x] = best;
                    return best;
                }
            * 위 코드는 각 x에 대해 단 한 번씩만 계산하기 때문에 효율적이다.
            * 이 알고리즘의 시간복잡도는 O(nk)가 되며, 이 때 n은 만들고자 하는 동전의 합이고 k는 동전 종류의 개수이다.
            * value 배열을 구할 때 다음과 같이 반복문을 이용할 수도 있다.
                ```
                value[0] = 0;
                for (int x=1; x<=n; x++) {
                    value[x] = Inf;
                    for (auto c : coins) {
                        if (x-c >= 0) {
                            value[x] = min(value[x], value[x-c]+1);
                        }
                    }
                }
                ```
            * 재귀를 사용하면 동적 계획법을 나타내기는 쉬우나, **반복문을 쓰는것이 코드가 더 짧고 실행속도도 더 빠르다.**
        * 해답 구성하기
            * 문제에 따라 최적해의 값 뿐 아니라, 어떻게 만들어졌는지를 구해야 하는 경우도 있다.
            * 동전 문제에서 최적해의 구성을 알아보기 위해 새 배열을 만들어 각각의 합을 만들기 위해 어떤 동전을 선택하는지를 저장한다.
                ```
                inf first[N];
                value[0] = 0;
                for (int x=1; x<=n; x++) {
                    value[x] = Inf;
                    for (auto c : coins) {
                        if (x-c >= 0 && value[x-c]+1 < value[x]) {      // 처음은 Inf이므로 무조건 저장, 그 후로 비교하며 최저값 저장
                            value[x] = value[x-c]+1;
                            first[x] = c;
                        }
                    }
                }

                while (n > 0) {     // 최적해 구성을 출력하는 부분
                    cout << first[n] << "\n";
                    n -= first[n];
                }
                ```
        * 해의 개수 세기
            * 동전 문제의 변형으로 합 X를 만드는 경우의 수를 세는 문제는 다음과 같이 풀 수 있다.
            * 예를 들어 coins = {1, 3, 4}이고 x=5 이면 6가지 방법이 존재한다. ( 1+1+3 과 1+3+1, 3+1+1을 각각의 경우로 봄)
            * 점화식은 다음과 같다 'sovle(x) = solve(x-1) + solve(x-3) + solve(x-4)'
            * 기저 조건은 x=0 인 경우 sovle(0) = 1이다. 합을 0으로 만드는 경우는 동전을 선택하지 않는 경우 한가지 뿐이다.
            * 그 외의 경우 모든 coins 값 c에 대해 solve(x-c)의 값을 더함으로써 구할 수 있다.
            * 다음은 solve(x)의 값을 count[x] 배열에 저장하는 코드이다.
                ```
                count[0] = 1;
                for (int x=1; x<=n; x++) {
                    for (auto c : coins) {
                        if (x-c >= 0) {
                            count[x] += count[x-c];
                        }
                    }
                }
                ```
            * 몇몇 문제는 정확한 값 대신 이를 특정한 값 m으로 나눈 나머지를 구하는 경우도 있다.
            * 이럴 때는 모든 계산에 m에 대한 나머지 연산을 추가하면 된다.
            * 즉, 'count[x] += count[x-c];' 밑에 'count[x] %= m;'을 추가한다.
        * 동전 문제와 탐욕법
            * 일반적인 동전문제를 떠올리면 가장 큰 동전부터 선택해 나가면, 최적이 될 것이라고 오인하여 떠올리기 쉽다.
            * 하지만, 최소한의 동전을 써서 특정값을 만드는 문제에서 탐욕법이 최적해로 성립하려면, 모든 큰 동전은 작은동전의 배수가 되야한다.
            * 위와 같은 조건이 성립하지 않을 시, 동전문제에서 탐욕법은 최적해를 구하지 못 한다.
            * 예시) 동전이 1, 4, 5일 때 8을 만들어라. 탐욕법 = (5,1,1,1) but 최적해 = (4,4)
* 6.2 다른 예제
    * 1) 최장 증가 부분 수열(longest increasing subsequence)
        * 원소가 n개인 배열의 일부 원소를 골라내어 만든 부분 수열 중에서, 각 원소가 이전 원소보다 크다는 조건을 만족하면서 그 길이가 최대인 것
        * length(k)를 위치 k에서 끝나는 최장 증가 부분 수열의 길이라고 하자
        * length(k)의 값을 계산하기 위해서는 array[i] < array[k]이면서 length(i)가 최대가 되는 위치 i < k를 찾아야 한다.
        * 그러면 length(k) = length(i) + 1임을 알 수 있다. 이는 i에서 끝나는 최장증가부분수열의 마지막에 array[k]를 추가하는 것이 최적이기 때문이다.
        * 이를 만족하는 i값 없다면 부분 수열을 array[k]만을 포함하게 되서 length(k) = 1이 된다.
            ```
            for (int k = 0; k < n; k++) {
                length[k] = 1;
                for (int i = 0; i < k; i++) {
                    if (array[i] < array[k]) {
                        length[k] = max(length[k], length[i]+1);
                    }
                }
            }
            ```
            * 위 알고리즘은 O(n^2) 시간에 동작한다. 이분탐색을 이용하면 O(nlog(n))에 풀 수 있다.
            * 새 배열을 만들고 각 원소가 배열에 어느위치에 들어갈지 이분탐색을 이용해 판별하여 마지막 수가 최소가 되도록 한다.
    * 2) 격자상의 경로 
        * n x n의 격자가 있고, 각 칸에는 점수가 지정되있다. 왼쪽위에서 오른쪽 아래로 가는 경로 중 점수의 합을 최대화 시키는 경우를 구하라
        * 말은 경로상에서 오른쪽과 아래쪽으로 밖에 움직이지 못한다.
        * 격자에서 행과 열의 번호를 1..n까지라고, value[y][x]가 (y,x)지점의 값이라고 가정할 때 이 문제는 동적 계획법을 이용해 다음과 같이 푼다.
        * 왼쪽 위 지점에서(y,x) 지점까지의 경로의 최댓값을 sum(y,x)라고 하면, sum(n,n)은 왼쪽위에서 오른쪽아래 까지 경로 중 최대값을 나타낸다.
        * sum()은 다음과 같이 성립한다. 'sum(y,x) = max(sum(y,x-1), sum(y-1,x)) + value[y][x]' 이는 말이 오른쪽과 아래로 밖에 움직이지 못하기 때문이다.
            ```
            int sum[N][N];
            for (int y=1; y<=n; y++) {      // O(n^2) 시간복잡도
                for (int x=1; x<=n; x++) {
                    sum[y][x] = max(sum[y][x-1], sum[y-1][x]) + value[y][x];
                }
            }
            ```
    * 3) 짐싸기 문제(Knapsack)
        * 짐싸기는 여러 물건이 있을 때 특정한 조건을 만족하는 조합을 구하는 문제를 의미한다. 많은 경우 동적 계획법을 이용해 풀 수 있다.
        * 각 짐의 무게를 나타내는 목록 [w1, w2, ..., wn]이 있을 때 이를 조합하여 만들 수 있는 모든 합을 구하는 문제를 생각해보자
        * ex) 무게의 목록이 [1, 3, 3, 5]일 경우 0~12중 2와 10을 제외한 나머지 값을 합으로 만들어낼 수 있다.
        * 첫 k개의 값만으로 합을 만드는 부분문제를 생각해 보자. 처음 k개의 무게를 사용하여 합 x를 만들 수 있으면 possible(x, k) = true
        * 만들 수 없으면 possible(x, k) = false 리고 한다. 이 함수는 다음과 같은 공식을 이용하여 재귀적으로 구할 수 있다.
        * possible(x,k) = possible(x-wk, k-1) or possible(x, k-1)
        * 이 문제의 기저조건은 possible(x, 0)이 x = 0일 때 true, x !=0 일때 false여야 한다.
        * 모든 무게의 합을 m이라고하면 다음과 같이 O(nm)인 동적 계획법 코드를 만들 수 있다.
            ```
            possible[0][0] = true;
            for (int k=1; k<=n; k++) {
                for (int x=0; x<=m; x++) {
                    if (x-w[k] >= 0) {
                        possible[x][k] |= possible[x-w[k]][k-1];
                    }
                    possible[x][k] |= possible[x][k-1];
                }
            }
            ```
        * 이 문제는 다음과 같은 방법으로 최적화 시킬 수 있다.
            ```
            possible[0] = true;
            for (int k=1; k<=n; k++) {
                for (int x=m-w[k]; x>=0; x--) {
                    possible[x+w[k]] |= possible[x];
                }
            }
            ```
        * 이는 계산과정에서 1차원 배열만을 사용하는 방법으로 효율적이다.
        * 다만, 이 방법을 위해선 오른쪽(값이 큰 경우)부터 왼쪽의 순서로 계산하는 트릭을 사용해야 올바르게 동작한다.
    * 4) 순열을 부분집합으로 바꾸기
        * 동적 계회법을 사용하다 보면 몇몇 문제는 순열에 대한 반복을 부분집합에 대한 반복으로 바꿀 수 있다.
        * 순열의 개수가 n!인 것에 비해 부분집합의 개수는 2^n이기 때문에 부분집합으로 바꾸어 풀면 훨씬 효율적이게 된다.
        * ex) 최대 하중이 x인 엘리베이터가 있고 1층에서 꼭대기 까지 가려고 하는 사람이 n명 있다.
        * 각 사람을 0,1,...n-1이라 하고 i번째 사람의 무게를 weight[i]라고 하자. 모든 사람이 꼭대기에 가려면 최소 몇 번 엘리베이터를 운행해야 하는가?
            ```
            x = 12이고 n = 5이며 무게는 다음과 같다.
            weight[0]=2, weight[1]=3, weight[2]=4, weight[3]=5, weight[4]=9
            ```
        * 이 경우 최소 운행 횟수는 2이고, 최적해 중 하나는 0,2,3 => 1,4번 사람 순으로 타는것이다.
        * 이 문제를 순열을 이용해 풀면 O(n!n)이지만, 부분집합을 이용하면 O(2^n*n)으로 풀 수 있다.
        * 모든 부분집합에 대해, 최소 운행 횟수와 마지막으로 타는 사람들의 무게의 합의 최솟값을 계산하면 된다.(최솟값인 이유는 다음에 누군가 추가로 태울수도 있기 때문)
        * 부부집합 S에 대한 값을 계산하려면 S에 속하는 모든 사람을 하나씩 살펴보고, 마지막에 엘리베이터를 타는 사람 p의 최적해를 구해야 한다.
        * last(S\p) + weight[p] <= x라면 마지막으로 운행할 때 p번째 사람도 같이 탄다. 그렇지않으면 p번째 사람을 위해 운행횟수를 증가시켜야 한다.
        * 이 문제의 동적계획법 풀이는 비트연산을 이용하면 쉽게 나타낼 수 있다.
            ```
            pair<int, int> best[1<<N]  // 부분집합 S에 대해 (rides(S), last(S))의 조합을 저장. ride는 최소운행횟수, 
            best[0] = {1, 0}    // 사람이 없는 경우     // last는 최소 운행일 때 마지막으로 타는 사람들의 무게의 합의 최솟값
            for (int s=1; s<(1<<n); s++) {
                best[s] = {n+1, 0};
                for (int p=0; p<n; p++) {
                    if (s & (1<<p)) {               // 집합 S에서 p번째 사람이 탑승한 경우
                        auto option = s ^ (1<<p);   // xor연산, 집합 S에서 p번째 사람을 제외하고 탑승한 사람들의 집합
                        if (option.second + weight[p] <= x) {   // option에 마지막 운행에 p번째 사람이 탈 수 있으면 
                            option.second += weight[p];         // 탑승
                        } else {                                // 못 타면 운행횟수 증가 후 다음차례 혼자 탑승
                            option.first++;
                            option.second = weight[p];
                        }
                        best[s] = min(best[s], option);
                    }
                }
            }
            ```
        * 위 반복문에서 부분집합 S1, S2가 모든 S1⊂S2일 떄, S1이 S2보다 먼저 처리되므로 이 코드는 올바른 순서로 계산을 수행한다.
    * 5) 타일 세기
        * 동적 계획법의 **상태를 정의하는 방법을 바꾸면 좀더 간단한 코드를 작성할 수 있는 문제가 존재한다.**        
        * ex) 4 x 7 를 1x2, 2x1타일을 이용해 채우는 경우의 수를 계산하는 문제. 이 문제의 경우의 수는 총 781가지가 나온다.
        * 이 문제는 격자를 행단위로 하나씩 살펴보는 동적계획법을 이용해 풀 수 있다. 
        * 각 행은 {∩,∪,⊂,⊃}의 네 글자로 이루어진 길이 m의 문자열로 나타낼 수 있다.
        * 격자의 각 행에 1부터 n까지의 번호를 붙이고 count(k,x)를 1행부터 k행까지 만들 수 있는 경우의 수로 정의하자. 이 때 x는 k행에 해당하는 문자열이다.
        * 각 행이 유효한지는 직전행만 살펴보면 알 수 있기 때문에 동적 계획법을 적용할 수 있다.
        * 해가 유효하려면 1행에는 ∪가 없고 n행에는 ∩가 없어야 하며, 인접한 행은 서로 호환되어야 한다.
        * 각 행은 문자 m개로 구성되며 문자는 네가지 이기 때문에 각 행에 대해 4^m, 직전 행에 영향을 받으므로 직전 행 4^m.
        * 결국 총 시간 복잡도는 O(n4^(2*m))이 된다. 실제로 구현할 때, 격자를 회전하여 짧은 쪽의 길이가 m이 되도록하면 더 효율적이다.
        
        * 행을 나타내는 방법을 좀 더 간결하게 바꿔보자. 
        * 이전 행에서 어느 열에 세로 타일의 윗부분이 있는지만 알면 된다.
        * 따라서 각 행은 ㅁ과 ∩만 이용하여 표현할 수 있다. 이 때 ㅁ은 {∪,⊂,⊃}를 모두 나타낸다.
        * 이 표현을 이용하면 서로 다른 행의 개수는 2^m이 되므로 시간 복잡도는 O(n*2^(2*m))이 된다.


# 7장. 그래프 알고리즘
* 7.1 그래프 기본
    * 7.1.1 그래프 용어
        * 그래프는 노드(정점, vertex)와 그 사이를 잇는 간선(edge)로 구성된다.
        * **경로(path)**는 한 노드에서 간선을 지나 다른 노드까지 가는 길을 의미한다.
        * 경로의 길이는 간선의 개수 또는 간선에 주어진 가중치의 합으로 표시한다.
        * **사이클(Cycle)**은 처음노드와 마지막 노드가 같은 경로를 의미한다.
        * 모든 노드 간에 **경로**가 있는 경우를 **연결그래프**(connected graph)라고 한다.
        * 그래프의 연결된 부분(집합)을 **컴포넌트**라고 한다. 
        * **트리(tree)**는 사이클이 없는 연결 그래프를 의미한다.
        * **방향 그래프(directed  graph)**에서는 간선의 한 방향이 정해져있다.
        * **가중 그래프(weighted graph)**는 간선마다 가중치 존재한다.
        * 두 노드를 잇는 간선이 존재할 때, 두 노드를 **이웃(neighbor) 노드**, 또는 **인접한(adjacent) 노드**라고 한다.
        * 노드의 **차수(degree)**는 이웃 노드의 개수이다. 그래프의 간선 개수가 m일 떄, 차수의 합은 항상 2m이다.
        * 모든 노드의 차수가 상수 d로 같을 때, **정규 그래프(regular graph)**라고 한다.
        * 모든 두 노드 간에 간선이 있는 경우는 **완전 그래프(complete graph)**라고 한다.
        * 방향 그래프에서 진입차수(indegree)는 그 노드로 향하는 간선의 개수이며 진출차수(outdegree)는 그 노드에서 시작하는 간선의 개수이다.
        * 어떤 그래프의 모든 노드를 두 가지 색깔 중 하나로 칠하되, 이웃 노드의 색깔이 같은 경우가 없도록 만들 수 있다면
        * 이 그래프를 **이분 그래프(bipartite graph)**라고 한다. 이는 홀수 개의 간선으로 이루어진, 사이클이 없는 경우와 일치한다.
    * 7.1.2 그래프의 표현
        * 그래프는 알고리즘에 따라 여러가지로 표현가능하다.
        1. 인접 리스트(Adjacency list) 표현법
            * 그래프의 각 노드 x에 대한 인접 리스트, 즉 x에서 출발하는 간선이 있는 노드의 리스트를 관리한다.
            * 가장 보편적이며, 알고리즘 대부분을 효율적으로 해결
            * C++에서는 벡터 배열로 인접리스트를 편하게 관리한다.
                """
                vector<int> adj<N>;     // N은 노드의 갯수
                adj[1].push_back(2);    // 1번 노드 진출, 2번 노드 진입
                adj[2].push_back(3);    // 2번 노드 진출, 3번 노드 진입
                adj[2].push_back(4);
                adj[3].push_back(4);
                adj[4].push_back(1);
                """
            * 무방향 그래프는 각각의 간선을 양방향에 대해 저장한다.
            * 가중 그래프에 대해서는 다음과 같이 확장한다.
                """
                vector<pair<int, int>> adj[N];  // 이 경우 노드 a의 인접리스트에는 (b,w)형태의 정보자 저장된다.
                adj[1].push_back({2, 5});       // 이는 노드 a에서 노드 b로 향하는 가중치가 w인 간선이 있음을 의미한다.
                adj[2].push_back({3, 7});
                adj[2].push_back({4, 6});
                adj[3].push_back({4, 5});
                adj[4].push_back({1, 2});
                """
            * 인접리스트를 이용하면 주어진 노드에서 출발하여 갈 수 있는 노드를 효율적으로 구할 수 있다.
                """
                for (auto u : adj[s]) {     // 노드 s에서 갈 수 있는 모든 노드를 처리한다.
                    // 노드 u를 처리한다.
                }
                """
            
        2. 인접 행렬(Adjacency matrix)를 이용
            * 인접 행렬은 그래프에 포함된 간선을 나타내는 행렬이다.
            * 인접 행렬의 장점은 두 노드 사이에 간선이 있는지를 효율적으로 확인할 수 있다는 것이다.
            * 인접 행렬은 다음과 같이 나타낸다.
                """
                int adh[N][N];  // adj[a][b]는 노드 a에서 노드 b로 향하는 간선이 있는지를 나타낸다.
                    // 1일 경우 간선이 해당 간선이 존재하고, 0인 경우는 존재하지 않음을 의미한다.
                """
            * 가중 그래프에 대해서는 각각의 값이 간선의 가중치를 나타내도록 확장한다.
            * 이는 간선이 존재하지 않으면 0, 존재할 경우 0이 아닌 숫자가 들어가는 방식이다.
            * 인접 행렬은 원소의 개수가 n^2개이고 그 중 대부분은 0으로 채워진다는 단점이 있다.
            * 따라서 그래프의 크기가 적당히 작을 때만 사용할 수 있다.

        3. 간선 리스트(Edge list) 
            * 간선 리스트는 그래프의 모든 간선을 특정한 순서에 따라 저장한 리스트이다.
            * 이 방식은 알고리즘이 모든 간선을 살펴보는 형태이고, 특정 노드에서 출발하는 간선을 알 필요가 없을 때
            편리하다.
            * 간선 리스트는 다음과 같은 벡터로 저장할 수 있다.
                """
                vector<pair<int, int>> edges;   // 원소 (a, b)는 노드 a에서 노드 b로의 간선을 의미한다.
                edges.push_back({1, 2})
                edges.push_back({2, 3})
                edges.push_back({2, 4})
                edges.push_back({3, 4})
                edges.push_back({4, 1})
                """
            * 가중 그래프의 경우 다음과 같이 확장한다.
                """ 
                vector<tuple<int, int, int>> edges; // 원소 (a, b, w)는 노드 a에서 노드 b로의 가중치가 w인 간선을 의미한다.
                edges.push_back({1, 2, 5})
                edges.push_back({2, 3, 7})
                edges.push_back({2, 4, 6})
                edges.push_back({3, 4, 5})
                edges.push_back({4, 1, 2})
                """
* 7.2 그래프 순회
* 그래프의 특정 노드를 시작 노드로 삼아, 그 노드에서 도달 가능한 모든 노드를 방문하는 알고리즘
    1. **깊이 우선 탐색(Depth-First Search, DFS)**
        * DFS는 시작 노드에서 출발하여 그래프의 간선을 따라 이동해가며 도달 가능한 모든 노드를 처리한다.
        * DFS는 새로운 노드가 발견되는 동안 단일한 경로를 따른다. 
        * 그 후 방문했던 이전 노드로 돌아가 그래프의 다른 부부을 탐색한다.
        * 방문한 노드를 기록하여 각 노드를 한 번씩만 처리한다.
        
        * 구현
            * 깊이 우선 탐색(DFS)은 재귀를 이용해 편리하게 구현 가능하다.
                """
                vector<int> adj[N]; // 그래프가 인접 리스트 형태로 저장되어 있다.
                bool visited[N];    // 방문했던 노드를 기록하기 위한 배열, 초기값 = false
                // DFS 함수
                void dfs(int s) {
                    if (visited[s]) return;
                    visited[s] = true;
                    // 노드 s를 처리한다.
                    for(auto u: adj[s]) {
                        dfs(u)
                    }
                }
                """
            * 깊이 우선 탐색의 시간복잡도는 O(n+m)으로 n은 노드, m은 간선의 개수이다.
            * 알고리즘이 각 노드와 간선을 한 번씩 처리한다.
    2. **너비 우선 탐색(Breadth-First Search, BFS)**
        * BFS는 시작 노드에서 각 노드까지의 거리가 증가하는 순서대로 노드를 방문하는 방식이다.
        * 특정한 시작 노드에서 각 다른 모든 노드까지의 거리를 BFS를 통해 계산할 수 있다.
        * 너비 우선 탐색(BFS)은 노드를 단계별로 차례차례 방문한다. 
        * 먼저 시작 노드와의 거리가 1인 노드르 방문하고, 그 다음 거리가 2인 노드, 그 다음 거리가 3인 노드..를 방문하는 식이다.
        * 이 과정을 반목하며 모든 노드를 방문할 때까지 진행한다.
        
        * 구현
            * **노드 방문이 그래프에 여러 부분에 걸쳐 진행**되서, DFS보다 구현이 어렵다.
            * 일반적인 구현은 방문할 노드를 관리하기 위한 큐를 사용. 단계마다 큐에서 다음 노드를 가져와 처리한다.
                """
                queue<int> q;   // 처리할 노드가 시작노드와의 거리가 증가하는 순서대로 들어간다.
                bool visited[N];    // 방문한 노드를 저장
                int distance[N];    // 노드별로 시작 노드와의 거리가 저장

                // 노드 x에서 시작하는 너비 우선 탐색
                visited[x] = true;
                distance[x] = 0;
                q.push(x);
                while(!q.empty()) {
                    int s = q.front(); 
                    q.pop();
                    // 노드 s를 처리한다.
                    for (auto u : adj[s]) {
                        if (visited[u]) continue;
                        visited[u] = true;
                        distance[u] = distance[s] + 1;
                        q.push(u);
                    }
                }
            * 깊이 우선 탐색과 마찬가지로, 너비 우선 탐색의 시간복잡도도 O(n+m)이 된다.





