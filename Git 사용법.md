## git

git : 소스코드 버전관리 시스템, github : git으로 관리하는 프로젝트를 올려둘 수 있는 git 호스팅 사이트
Git Bash : 리눅스 기반 터미널. 리눅스, 맥과 같은 운영체제의 터미널과 같은 명령어로 git을 관리할 수 있게 해준다.
.git : 최초 'git init' 실행 시 자동 생성되는 파일로 git으로 생성한 버전들의 정보와 원격저장소의 주소 등을 저장한다. 로컬저장소라고 부른다.
커밋(commit) : git(버전관리)을 통해 생성된 각각의 버전.
.md 확장자 : 마크다운 문서. .txt 확장자와 마찬가지로 텍스트문서 파일이다. 특정 문법을 이용하여 서식을 지정할 수 있다.
origin : 연결한 원격저장소의 닉네임(주소)
master : 커밋을 올리는 '줄기'
Collaborator(협력) : 프로젝트의 주체, 정식적으로 초대받은 최초 프로젝트 개발자
Contributor(기여) : 오픈소스 프로젝트의 기여자. 
Gmail '+' 기능 : 회원가입 시, gmail을 이용하면 example@gmail.com, example+sub@gmail.com, example+05@gmail.com 등으로 '+' 뒤에 아무 글자를 붙여서 가입해도 exmaple@gmail.com으로 모든 메일을 받을 수 있다. 

## Setting
* git init : 현재 폴더를 git 로컬저장소(Local repository)로 만든다 or 초기화시킨다.
* commit을 생성하기 전에, 먼저 사용자 정보를 등록해야 한다. (각 버전의 생성자를 명시)
  * git config --global user.email "example@email.com"
  * git config --global user.name "exampleName"
  * config는 환결설정이라는 의미. 일반적으로 프로그램의 설정을 저장하는 파일을 의미한다.


## Using Local
* git add [fileName] : commit에 추가할 파일을 선택한다
* git commit -m [message] : 해당 버전에 대한 설명이나 추가/수정된 내용 등. commit에 상세설명을 작성한다.
* git log : 현재까지 만들었던 commit을 확인한다. 최신 commit부터 보여준다.

* git checkout [commitId] : 해당 commit으로 버전을 되돌린다. commitId는 전체를 써도되지만, 일반적으로 앞에서부터 7글자를 사용한다.
* git checkout - : 최신 commit으로 버전을 되돌린다. '-' 가 최신 commit을 의미한다.


## Using with Github
* Local to Remote repository
 * 로컬저장소에 commit을 원격저장소(Remote repository)에 올리기 위해선, 먼저 로컬저장소에 원격저장소 주소를 알려야한다.
 * git remote add origin "https://github.com/username/example" : Github 등에서 생성한 원격저장소의 주소를 로컬저장소에 알린다.
 * git push origin master : 로컬저장소의 commit을 원격저장소에 올린다.

* Remote to Local repository
 * 클론(Clone) : 원격저장소의 코드와 버전 전체를 내 컴퓨터로 내려받는 것. 최시 버전뿐 아니라 이전 버전들과 원격저장소의 주소 등이 내 컴퓨터에 로컬저장소에 저장된다.
 * 원격저장소의 정보를 클론해오고 싶을 경우, 먼저 내려받을 위치(로컬저장소)를 지정해줘야 한다. 
 * Download ZIP : Github에서 지원하는 다운로드 기능. 원격저장소 주소와 버전정보가 제외된다.
 * git clone [Github 주소] . : 해당 Github 페이지에 저장소를 내려받는다. 주소 이후 한칸 공백 후 '.'은 현재 위치에 내려받으라는 것. 미작성 시 해당 저장소 이름으로 폴더가 생성된다.
 * git pull origin master : 원격저장소의 커밋을 로컬저장소에 내려받는다.
 * clone과 pull의 차이 : clone 리모트 설정을 자동으로 해주는 초기 다운로드에 사용, pull은 리모트 설정이 이미 돼있을 때 업데이트 사항 등을 다운로드 할 때 사용한다.
 clone은 로컬과 원격저장소의 내용을 일치시키고 pull은 변경사항이 있을 경우 병합까지 수행한다.


## Using GUI sourcetree
* [Sourcetree-Atlassian] (https://www.sourcetreeapp.com/)
sourcetree는 git을 이용한 프로젝트 관리를 GUI환경, 다시말해 클리과 화면조작으로 가능하게 만듭니다.
sourcetree는 직관적이며, 아름답기 때문에 많은 개발자들이 사용합니다.
sourcetree를 이용하면 commit을 그래프로 확인하고, 생소한 명령어 대신 누구나 쉽게 프로젝트 관리가 가능합니다.

* Get Remote Repository
  * Github의 아이디로 로그인하면 원격저장소가 자동으로 sourcetree에 올라옵니다.
  * Clone을 선택하여 원격저장소에 있는 프로젝트를 로컬에 내려받을 수 있습니다.
* Get Local Repository
  * 로컬저장소는 자동으로 추가되지 않아 수동으로 추가해줘야 합니다.
  * Add 기능을 이용하여 직관적으로 경로를 추가할 수 있습니다.
  * Create 기능은 내 컴퓨터에 새로운 로컬저장소를 생성합니다. 이것은 Git Bash에서 'git init' 명령을 수행한 것과 같은 의미를 갖습니다.

* about Local repository
  * sourcetree는 커밋을 그래프로 보여줍니다. 이는 .git 폴더에 저장된 정보를 사용합니다.
  * .git 폴더는 최초 'git init' 초기화 시, 생성되며 git은 .git폴더에 버전 관리한 데이터와 이를 올릴 원격저장소의 주소 등을 저장합니다.

* Commit
  * 로컬에서 에디터를 이용해 파일을 추가/삭제/수정 한 경우, sourcetree의 해당 repository로 이동하면 '커밋하지 않은 변경사항' 알림을 볼 수 있다.
  * 이는 기존 커밋에 비해 새로 만들어지거나 수정, 삭제된 파일의 목록을 보여준다.
  * 이러한 목록들의 파일을 커밋하기 위해선, 좌측 상단의 '커밋' 기능을 사용할 수 있다. 커밋기능에선 '+' 버튼을 클릭해 수정된 파일을 스테이지에 올릴 수 있고 commit에 멘션도 작성할 수 있다. 
  * CLI에서도 그렇듯이 모든 수정된 프로젝트는 Githube에 올라가기 전에(커밋되기 전에) git add 명령이나, sourcetree에 '커밋' -> '+' 버튼을 클릭한 것 처럼 스테이지에 먼저 올라간다.
  * 이렇게 커밋을 하게되면 로컬저장소(.git)에 기존 버전에 대한 정보가 저장되고, 기존 버전의 파일은 신규 커밋으로 바뀌게 된다.
  이 상태에서 원격저장소의 버전은 바뀌지 않으므로, 현재 원격저장소는 상대적으로 구버전을 가지고있다.
    * origin/master : 원격저장소의 현재 버전 상태.
    * master : 로컬저장소의 버전 상태.
  * 원격저장소와 로컬저장소의 버전을 맞추기 위해, 또는 원격저장소에 업로드할 목적이라면, 로컬저장소의 새로운 커밋을 'push' 해줘야한다.
    *push 과정을 거치면 로컬과 원격저장소의 버전을 맞출 수 있다.

* Branch
  * Branch 이름에 '/'를 넣게되면( ex) feature/detail ), '/'앞에 feature가 폴더명인 폴더안에 detail파일을 만든 것 처럼 볼 수 있다.

* Add multi remote repository
  * source tree를 이용하면 하나의 로컬저장소에서 두 개 이상의 원격저장소를 관찰할 수 있다.
  * 상단의 [저장소]-[원격 저장소 추가]를 통해 하나의 로컬저장소에서 여럿 원격저장소를 추적할 수 있다.
  * [원격 저장소 추가] 기능은 CLI에서 'git remote add origin [원격저장소주소]'를 수행한 것과 같다.
  * upstream : 원격저장소를 지칭하는 관용적 닉네임
  * 원격저장소를 추가한 후에, 해당 저장소에 대한 추적을 시작하기 위해선, Fetch 과정을 거쳐야한다. 해당 원격저장소에서 [...에서 가져오기] 기능을 사용할 수 있다.

## About git
* git의 커밋 저장 방식
  * 기존의 버전 관리 시스템과 git의 차이점은 git은 변경사항만을 저장하지 않고, 변경된 파일을 통째로 저장한다. 
  * 변경사항을 저장하기 위해선, 이전 버전과의 차이점을 일일히 계산해야하기 때문에 오히려 계산과정이 복잡해진다. 따라서 git은 변경사항이 있는지만 연산을 한다.
  * 또한, 바뀌지 않은 파일에 대해서는 이전 파일의 링크만을 저장하기 때문에 git은 여러 복잡한 명령어들을 빠르게 처리할 수 있다.
  * 소스트리에서 커밋을 선택했을 때에는 git이 자동으로 앞뒤 커밋을 차이점을 계산해서 보여준다.
  * 이러한 git의 저장 방식을 **Snapshot** 방식이라고 한다.
  
* git의 장점, branch
  * git의 branch는 포인터다. 따라서 가리키는 것 만으로 새로운 분기를 만들 수 있다.
  * SVN과 같은 버전 관리 툴은 새 분기를 만들기 위해 프로젝트를 통째로 복사하므로 무겁고, 시간이 많이 걸린ㄷ.
  * 반면, git의 branch는 독립적인 프로젝트를 따로 생성하지 않고 '가리키는' 방식이기 때문에 비교적 가볍고 빠르다.

## Git Status
  * git으로 관리되는 파일은 untracked(추적안됨), tracked(수정없음, 수정함, 스테이징됨)의 총 네가지 상태를 가진다.
  * 새로 파일을 만들경우 해당 파일은 untracked 상태가 된다.
  * add 명령을 통해 스테이지에 올릴 경우, 해당 파일을 스테이징 상태가 된다.
  * commit을 통해 스냅샷, 버전으로 만들면, 해당 파일들은 모두 수정없음 상태가 되고, 이렇게 수정없음 상태가 된 파일은 다시 다른 수정이 가능하다.
  * 수정없음 상태의 파일을 수정하면, '수정' 상태가 되고 해당 파일을 add하면 다시 '스테이징' 상태가 된다.
  * 주의할 점은 최초 add명령어를 통해 스테이지에 올려둔 파일들은 commit이나 push 이후 삭제되지 않았다는 점이다.
  * 따라서 add 명령을 통해 수정한 파일을 스테이지에 올릴 경우에만 원래 스테이징돼 있던 파일과 교체되고, **수정되지 않은 파일은 스테이지에 그대로 존재한다.**

## Branch
두명 이상의 개발자가 협업할 경우, 같은 버전(커밋)을 가지고 각각의 개발자가 수정할 수 있게한다.
일반적으로 혼자 개발하고 프로젝트를 관리할 때와 비교하자면, 혼자 개발하는 경우 커밋은 따로 줄기가 나눠지지 않고 시간순으로, 한 줄로 쌓이게 된다.
두명 이상의 개발자가 위와 같은 방식으로 같은 버전에서 프로젝트를 동시에 개발, 원격저장소에 푸쉬하게 될 경우 최초 커밋은 정상적으로 수행되지만, 
뒤늦게 푸시한 커밋은 이전 버전에 푸쉬를 하게되기 때문에 오류가 발생한다.
따라서 두 명 이상의 개발자가 동시에 협업하기 위해선, 한 줄이 아닌, 두 개 이상의 줄기로 나눠져야 한다. 즉, 분기가 필요하다.
현재 작업할 버전에 대해 여러 흐름(분기)을 만드는 것을 **Branch**라고 한다
* [master] 꼬리표 또한, 브랜치이다. [master]는 최신 버전의 커밋을 '가리키는' 브랜치다. (브랜치는 포인터와 같아서 '가리킨다'는 표현을 쓴다)
* Base : 새로운 branch를 만들어 분기가 여러 갈래로 나뉘었을 때, 해당 기준이 되는 커밋을 기준, base라고 한다.
* [HEAD] : [HEAD]는 브랜치 혹은 커밋을 가리키는 특수한 포인터다. 원하는 커밋을 [HEAD] 포인터가 가리키게 하면 과거 커밋으로 돌아갈 수도, 최신 브랜치로 돌아올 수도 있다.(checkout)
* [HEAD]를 조작해, [master] 브랜치가 아닌 다른 커밋이나 브랜치를 가리키는 상태를 분리된 HEAD(Detached Head)라고 한다.]

* Branch Rule
  1. [master] 브랜치에는 직접 커밋을 올리지 않는다(동시에 작업하다 꼬일 수 있으니)
  2. 기능개발을 하기 전에 [master] 브랜치를 기준으로 새로운 브랜치를 만든다
  3. 새로운 브랜치 이름은 [feature/기능이름] 형식으로 하고, 한 명만 커밋을 올린다.
  4. [feature/기능이름] 브랜치에서 기능 개발이 끝나면 [master]브랜치에 이를 합친다.

## Merge, 병합
* Merge commit : 두 커밋의 합집합(두 커밋 모두 수정된 내용일 경우)
* Fast-Forward : 한 커밋의 모든 내용이 다른 커밋에 종속될 경우
* Conflict : 수정된 부분이 중복될 경우, 무엇을 선택해야할지 결정해야되는 상태

* 병합 과정 
  1. [master] 브랜치를 기준으로 나뉜 여러개의 브랜치 중, 최초로 개발을 완료한 파트가 Fast-Forward 과정을 거쳐 [master] 브랜치가 된다
  2. 뒤이어 개발이 완료된 브랜치와 1의 과정을 거쳐 생성된 [master] 브랜치가 Merge commit이 된다. 
  3. 병합커밋이 생성될 때, 둘 중 어떤 브랜치에 새로운 병합커밋을 올린것인지 선택이 가능하다.

* Conflict, 충돌 발생 우려가 있는 경우
  1. 같은 분기에서 나눠진 두 커밋이 같은 코드를 고치게 되는 경우, 충돌이 일어날 수 있다.
  2. 따라서 Merge commit을 만드는 경우, 충돌이 발생할 수 있으므로 [master] 브랜치에 바로 병합하기보단 개인이 개발한 브랜치에서 먼저 병합해보고 문제가 없는지 확인한다.
  3. 병합된 커밋이 문제가 없음을 확인하고 나서 병합 커밋을 [master] 브랜치에 반영한다.
  
* Pull request : 내가 수정한 A 브랜치를 B브랜치에 병합해도 될까? 수정사항은 다음과 같아.
  1. 병합 시, 충돌만 해결했다고 [master] 브랜치에 병합하게 되면 [master]는 뒤죽박죽인 코드가 될 것이다.
  2. 따라서, 병합 전에 각 파트의 수정된 부분을 이해하고 서로 협력하기 위해, 다른 Collabrators가 확인하는 과정을 거친다.
  3. 이와 같이 브랜치 병합을 요청하는 메세지를 보내는 것을 풀 리퀘스트, **Pull request**라고 한다.
  4. Github에 Pull request에서는 코드의 라인별로 코멘트를 달아 개선방법이나, 변경사항에 대한 설명에 대해 토론할 수 있다.
  5. Github에서 Pull request를 통해 병합 후, 병합 결과를 소스트리에서 확인하기 위해선 **패치**를 해야한다.
  6. 패치(Fetch)는 새로고침과 같은 역할로, git에서 새로운 이력을 업데이트하는 명령어이다. (원격저장소의 커밋 히스토리를 받아온다.) 패치는 그래프만 업데이트한다는 면에서 실제 코드를 내려받는 Pull과는 차이점을 갖는다.

## Relesase와 Version
* 프로그램을 출시하는 것을 릴리즈(Release)라고 한다. 프로그램이 출시될 때, 일반적으로 프로그램의 버전을 명시한다. 
* 프로그램의 버전은 일반적으로 Major 업그레이드와 Minor 업그레이드로 나뉜다. 큰 변화가 일어난 경우 Major 버전을 올리고, 작은 변화 등이 생겼을 경우 Minor 버전을 올린다.
* 이외에도 메인터넌스 Maintenance 버전이란 것도 존재하는데, 이는 버그나 유지보수 등 작은 수정을 의미한다.
* 프로그램의 버전은 태그로 가리킬 수 있다. 태그는 특정 커밋에 짧은 내용의 포스트잇을 붙이는 것과 같다. '가리킨다'는 표현을 쓴 것은 태그 또한 포인터이기 때문이다.
* 태그 또한 푸시를 해줘야 원격저장소에서 확인할 수 있다. 이렇게 Github의 태그를 푸시하게되면, Release 페이지에서 해당 버전을 다운로드 받을 수 있다.


## fork, 다른 사람의 프로젝트에 추가한다.
fork는 남의 원격저장소를 내 계정의 원격저장소로 복사해오는 명령이다.
fork를 통해 원격저장소를 복사해 오는 것은, 프로젝트에 직접 커밋을 올리는 것과는 다르다. 
일반적으로 contributor는 남의 프로젝트에 커밋을 올릴 권한이 없다. Github 에서는 이름없는 참여자들의 참가를 위헤 원격저장소를 복사해오는, fork 기능을 제공한다.
다른 사람의 프로젝트를 복사해서 본인의 Github로 새로운 원격저장소를 만들고 마음대로 수정할 수 있다. 수정사항은 내 저장소에만 반영된다.
* 개발자는 fork를 통해 복사해온 원격저장소에 코드를 수정하고, 프로젝트 소유자에게 Pull request, 병합요청을 보낸다. 프로젝트 소유자는 병합 요청을 검토해서 프로젝트 원본에 반영한다.
* fork를 통해 남의 원격저장소를 복사해 올 경우, 최신 커밋뿐만 아니라 과거의 모든 커밋 이력을 통째로 복사해오게 된다.
* fork는 분기를 나눈다는 점에서 branch와 공통점을 갖는다. branch는 하나의 저장소에서 fork는 여러 저장소로 분기를 나눈다.

## Rebase(재배치), 커밋의 이력을 조작하다
협업을 하다보면 프로젝트 원본의 업데이트로 인해, 개발하고 있는 브랜치의 base가 상대적으로 구버전이 될 때가 있다.
또한, 이 과정에서 서로 같은 부분을 수정했다면 충돌이 일어날 우려가 있다. 이를 위한 해결방안 두가지를 설명한다.
1. 프로젝트 원본이 아닌, 기능 개발을 하고있는 다른 브랜치에 업데이트된 프로젝트 원본과의 병합커밋을 만들어 충돌을 해결한다.
  * 이 방법은 개발 브랜치에 불필요한 병합커밋이 하나 더 생긴다는 단점이 있다. 
2. 기능 개발 브랜치의 base를 프로젝트 원본의 [master]로 base를 이동시킨다. **Rebase**
  * 이렇게되면 프로젝트 원본의 최신커밋이 base가 되기 때문에, 병합시에 충돌없이 fast-forward를 수행한다.
  * 발생하는 충돌은 Rebase 시에 조용히 해결한다.

* Rebase는 이력을 강제 조작한다. 해당 히스토리를 보고있는 다른 개발자가 있다면 완전히 꼬여버리게 된다. 따라서, Rebase는 반드시 혼자 사용하는 브랜치에서만 해야한다.
* Rebase는 이러한 위험성을 갖기 때문에, 일반적인 push가 아닌 **강제 푸시**를 해줘야 한다.

## Amend, 커밋을 수정하다.
작업 후, 파일을 빼놓고 커밋을 올리거나 커밋 메세지를 잘못써서 보낼 때가 있다. 이 때 커밋을 하나 더 만들지 않고 이전 커밋을 수정하는 것이 amend다.
[Amend last commit]을 이용하면, 커밋의 내용이나 메세지를 수정할 수 있다. 이미 잘못된 커밋으로 원격저장소에 푸시까지 한 상황이라면, 로컬의 커밋을 수정 후 **강제 푸시**해야 한다.
강제 푸시는 로컬저장소의 변경사항을 원격저장소에 강제로 덮어씌우며 푸시하는 명령이다. 공용으로 사용하느 브랜치에서 강제푸시를 하면 다른 사람의 커밋 히스토리가 꼬이게 된다.
**강제푸시는 반드시 혼자만 쓰고있는 브랜치에서 실행해야 한다.**

## git workflow
[우아한 형제들 블로그](https://techblog.woowahan.com/2553/)
git flow는 git을 이용하여 개발할 때, 브랜치를 관리하는 전략이다.
기본적으로 master, develop, feature, release, hotfix 5가지 종류의 브랜치로 나눈다.
항상 유지되는 main 브랜치(mater, develop)과 일정 기간만 유지되는 브랜치(feature, release, hotfix) 브랜치가 있다.
* master : 바로 배포될 수 있는 브랜치. 큼직큼직한 개발이 완료된 버전이 올라가는 브랜치. release가 merge 되면 새로운 버전 태그를 붙인다.
* develop : 기능 개발 등 다음 버전을 만드는 브랜치
* feature : 기능 개발을 위해 develop 브랜치를 base로 만들어낸 브랜치. 기능 개발이 완료되면 develop 브랜치로 merge
* release : 기능 개발이 종료된 후, 프로그램 배포 전 QA를 위해 develop에서 생성한 브랜치. QA 시 발생하는 수정사항들은 release에 직접 반영한다. QA를 통과하면 develop과 master로 merge한다.
* hotfix : 현재 출시 버전에서 발생한 버그, 극심한 버그들을 긴급하게 수정하는 브랜치. 

## cherry-pick, 다른 브랜치의 원하는 커밋만 쏙 빼간다.
개발을 하다보면, 특히나 hotfix와 같은 버그 수정을 위해, 다른 브랜치의 특정 커밋만을 반영하고 싶을 때가 있다.
다른 브랜치의 커밋을 반영하기 위해 앞서 해왔던대로 병합을 할 수도 있다. 하지만 병합의 문제는 그 이전이나 이후의 커밋도 같이 적용된다는 것이다. 
그 누구도 기능 개발 중인 내용을 master에 올리고 싶지 않을 것이다. 이럴 때 **cherry pick**을 사용하면 원하는 특정 커밋만을 빼올 수 있다.

## reset, 옛날 커밋으로 브랜치를 되돌리다.
기능 개발을 완료한 브랜치에서, 해당 기능이 더이상 필요없어질 경우 현재까지의 작업이력을 커밋으로 남겨놨다면 손쉽게 돌아갈 수 있다.
이와 같이 옛날 버전(커밋)으로 브랜치를 되돌리는 일을 수행하는 명령이 **reset**이다. reset에는 3가지 옵션이 있다.
1. [Soft] : 원하는 커밋으로 이력을 되돌릴 때, 이후 추가했던 모든 변경사항을 스테이징 상태로 놓는다.
2. [Mixed] : 원하는 커밋으로 이력을 되돌릴 때, 이후 추가했던 모든 변경사항을 스테이지 아래로 내린다.
3. [Hard] : 원하는 커밋으로 강제적으로 되돌린다. 이후 추가했던 모든 변경사항을 무시(삭제)한다.
* 이미 push한 브랜치를 예전 커밋으로 깔끔하게(Hard 옵션) 되돌리기 위해선, 로컬의 reset을 수행한 후에 수행 내용을 **강제푸시**해야 한다.
* 이는 히스토리를 수정하는 푸시이기 때문이다. 다시 한 번 말하지만, 강제푸시는 히스토리를 꼬이게 만들 수 있기 때문에 혼자 사용하는 브랜치에서만 사용하도록 한다.

## **revert**, 커밋의 변경사항을 되돌리며 **기록을 남긴다.**
이력관리가 중요한 함께 쓰는 브랜치에서는 기록이 안 남는 reset보다 변경사항을 되돌리는 새로운 커밋을 만드는 것이 좋다.
revert, 커밋 되돌리기를 사용하면 바로 이전에 올린 커밋뿐 아니라 예전에 올린 커밋도 얼마든 되돌릴 수 있다.

## stash, 변경사항을 잠깐 저장했다가 나중에 다시꺼내 쓴다.
개발중인 브랜치에서 다른 브랜치로 이동해야 할 경우, 커밋하지 않은 파일들이 아직 커밋으로 만들기 애매할 때 잠깐 저장했다 나중에 다시 꺼낼 쓸 수 있다.
stash, 스태시 명령은 현재 브랜치의 변경사항을 저장한다. 현재 변경사항들에 대해 stash 명령을 수행할 경우, 현재 브랜치는 더 이상 커밋할 것도 수정사항도 없는 
깨끗한 상태로 돌아간다. 이 상태에서 다른 작업을 수행 후, 다시 stash에 저장된 변경사항들을 적용해 꺼내쓰면 된다.

# CLI로 Git 다루기
* CLI, Command Line Interface는 말 그대로 명령어를 직접쳐서 수행한다.
* CLI 환경에서 경로를 나타내는 '~'는 보통 'C:\Users\사용자ID'로 구성되는 유저 HOME을 의미한다.
* Git Bash로 Git 작업폴더에 들어가면 경로 뿐만 아니라 현재 브랜치까지 표시된다.
* Bash 기본 명령어
  * pwd : 현재 디렉토리 위치
  * ls [-a] : 현재 디렉토리의 파일 목록 확인, '-a' 옵션은 숨긴 파일까지 확인
  * cd : 홈으로 이동. cd 뒤 경로를 붙이면 해당 경로로 이동
  * mkdir <폴더이름> : 디렉토리 생성
  * echo "" : 메아리(echo), ""안에 문장 출력
* Git Bash는 Tab키를 이용하여 자동완성 기능을 사용할 수 있다.

* Git Bash 명령어
  * git status [-s] : git 워킹트리의 상태를 보는 명령. '-s' = 요약
    * 워킹트리(working tree) : 로컬저장소가 있는 현재폴더, 작업폴더에서 .git 폴더를 제외한 나머지 부분. 작업폴더
    * 로컬저장소 : [.git] 폴더, 커밋, 커밋을 구성하는 객체, 스테이지가 저장된다
    * Git 저장소 : Git 명령으로 관리할 수 있는 폴더, 일반적으로 워킹트리 + 로컬저장소의 의미, 공식문서에서는 로컬저장소와 같은 의미로 사용
  * git init : 현재 디렉토리에 git 저장소를 생성한다. (.git = 로컬저장소)
  * git config [--global] [--local] [--system] <옵션> [<새로운값>]
    * [--global] : 전역옵션, 현재 사용자를 위한 옵션
    * [--local] : 지역옵션, 현재 git 저장소에서만 유효한 옵션
    * [--system] : 시스템환경옵션, pc전체의 사용자를 위한 옵션
    * 우선순위 local > global > system
    * 옵션만 쓰면 해당 옵션을 확인, 새로운 값까지 쓰면 해당 옵션을 새로운 값으로 지정
    * core.editor 옵션 : git bash에서 사용하는 기본 에디터. 보통 vim으로 설정되어 있다.
  
  * git add 파일1 파일2 ... : 파일들을 스테이지에 추가한다. 새로 생성한 파일을 스테이지에 추가하고 싶다면 반드시 add명령을 사용한다.
  * git reset 파일1 파일2 ... : 스테이지 영역에 있는 파일들을 스테이지에서 내린다(언스테이징). 워킹트리의 내용은 변경되지 않는다. 
    * 옵션(soft,mixed,hard | default = mixed)을 생략할 경우 스테이지의 모든 변경사항을 초기화한다.
  * git commit [-a]: 스테이지에 있는 파이들을 커밋한다. '-a'옵션은 add명령을 생략하고 바로 커밋하고 싶을 때 사용.
    * '-a'옵션 사용 시, untracked 파일은 커밋되지 않는다는 점 주의.
    * CLI 환경에서 commit 메세지를 작성할 때, 첫 줄은 제목, 다음줄은 본문으로 나눠지므로 첫줄과 둘째 줄 사이는 반드시 한 줄을 비운다.
    * 커밋 메시지 작성 규칙
      1. 제목과 본문을 빈줄로 분리, 제목은 50자 이내로
      2. 제목을 영어로 쓸경우 첫글자 대문자. 제목에는 마침표를 넣지 않는다.
      3. 제목을 영어로 쓸경우 동사원형으로 시작한다. 본문을 72자 단위로 줄바꿈한다.
      4. 어떻게 보다 무엇을 왜를 설명한다.
  * git push [-u] [원격저장소별명] [브랜치이름] : 현재 브랜치에서 새로 생성한 커밋들을 원격저장소에 업로드한다. 
    * '-u'옵션으로 브랜치의 업스트림을 등록할 수 있다. 한 번 등록한 후에는 git push만 입력해도 된다.
  * git pull : 원격저장소의 변경사항을 워킹트리에 반영한다. fetch와 merge를 합친 명령이다.
  * git fetch [원격저장소별명] [브랜치이름] : 원격저장소의 브랜치와 커밋들을 로컬에 동기화한다. 옵션을 생략하면 모든 원격저장소에서 모든 브랜치를 가져온다.
  * git merge 브랜치이름 : 지정한 브랜치의 커밋들을 현재 브랜치 및 워킹트리에 반영한다.
  * git log : git 커밋 히스토리를 보여준다.
    * git log --oneline --graph --all --decorate : 커밋해시(=커밋체크섬 or 커밋아이디)와 커밋 제목을 보여준다.
    * 커밋 체크섬 : SHA1 해시 체크섬을 사용한다. 커밋에 전 세계에서 유일한 값을 부여한다.
    * SHA1은 값을 만드는 알고리즘, 해시 : 무언가를 잘게 쪼개서 섞음, 체크섬 : 데이터의 정확성을 확인하기 위헤 계산한 값
    * git log [-n] : 전체 커밋 중 최신 n개의 커밋만을 살펴본다. n은 상수
    * [--oneline] : 메세지를 한줄로 요약
    * [--graph] : 브랜치의 흐름을 그래프로 보여준다
    * [--all] : 'all'옵션이 없을 경우 HEAD와 관계없는 옵션은 보여주지 않는다.
    * [--decorate] : --decorate=short를 의미한다. 브랜치와 태그 등의 참조를 간결히 표시
  * git help <명령어> : 해당 명령어 도움말 표시
  * git remote add <원격저장소 이름> <원격저장소 주소> : 원격저장소를 등록한다. 원격저장소는 여러개 등록할 수 있지만, 같은 별명의 원ㄱ겨저장소는 하나만 가질 수 있다. 통상적으로 첫 번째 원격저장소를 origin으로 지정한다.
  * git remote -v : 원격저장소 목록을 살펴본다.
    * HEAD는 현재 작업 중 브랜치 혹은 커밋을 가리킨다.
  * git clone <저장소주소> [새로운 폴더명] : 저장소 주소에 프로젝트를 clone 해온다. 원겨저장소뿐만 아니라 로컬저장소도 clone해올수 있다.
    * [새로운 폴더명] 옵션을 적용하면 해당 이름으로 폴더를 생성해서 clone한다.

  * 브랜치 생성하기
    1. 커밋하면 커밋 객체가 생긴다. 커밋 객체에는 부모 커밋에 대한 참조와 실제 커밋을 구성하는 파일 객체가있다.
    2. 브랜치는 논리적으로는 어떤 커밋과 그 조상들을 묶어 뜻하지만, 사실은 단순히 커밋 객체하나를 가리킨다.
  * 브랜치를 사용하는 경우
    1. 새로운 기능 추가
    2. 버그 수정
    3. 병합과 리베이스 테스트
    4. 이전 코드 개선
    5. 특정 커밋으로 돌아가고 싶을 때
  * HEAD에 대해
    1. HEAD는 현재 작업 중인 브랜치를 가리킨다.
    2. 브랜치는 커밋을 가리키므로 HEAD도 커밋을 가리킨다.
    3. 결국 HEAD는 현재 작업 중인 브랜치의 최근 커밋을 가리킨다.
  * 브랜치 관련 명령
    * git branch [-v] : 로컬의 브랜치 목록을 본다.
      * '-v' 옵션은 마지막 커밋도 함께 표시한다. 브랜치 이름 왼쪽에 *가 붙어 있으면 HEAD 브랜치를 의미한다.
    * git branch [-f] <브랜치이름> [커밋체크섬] : 새로운 브랜치를 생성한다. 커밋체크섬 값을 주지않으면 HEAD 브랜치를 생성한다.
      * '-f' 옵션을 사용해 이미 있는 브랜치를 다른 커밋으로 옮길 수 있다.
    * git branch -r[v] : 원격저장소에 있는 브랜치를 보고 싶을 때 사용. -v로 커밋 요약 확인
    * git branch -d <브랜치이름> : 특정 브랜치를 삭제한다. HEAD브랜치나 병합이 되지 않은 브랜치는 삭제할 수 없다.
  * git branc -D <브랜치이름> : 브랜치를 강제로 삭제한다. -d로는 삭제할 수없을 브랜치를 지울 때 사용한다.
  * checkout 명령
    * git checkout <브랜치이름> : 특정 브랜치로 체크아웃. 
    * git checkout -b <브랜치이름> <커밋 체크섬> : 특정 커밋에서 브랜치를 새로 생성하고 동시에 체크아웃까지 한다.
  * merge 명령
    * git merge <대상브랜치> : 현재 브랜치와 대상브랜치를 병합한다.
  * rebase 명령
    * git rebase <대상브랜치> : 내 브랜치의 커밋들을 대상 브랜치에 재배치시킨다. 
  * reset 명령
    * git reset --hard <이동할 커밋체크섬> : 현재 브랜치를 지정한 커밋으로 옮긴다. 작업 폴더의 내용도 함께 적용된다.
      * 커밋체크섬 : 커밋체크섬을 CLI에서 직접 치는 대신 약칭을 사용할 수 있다.
        * HEAD~<숫자> : HEAD~은 헤드의 부모커밋, HEAD~2는 헤드의 할아버지 커밋을 말한다. HEAD~n은 n번째 위쪽 조상이라는 뜻이다.
        * HEAD^<숫자> : HEAD^도 똑같이 부모 커밋이다. 반면 HEAD^2는 두 번째 부모를 가리킨다. 병합커밋처럼 부모가 둘 이상인 커밋에서만 의미가 있다.
  * Tag 달기, tagging
    * git tag -a -m <메세지> <태그이름> [브랜치 또는 체크섬] : -a로 주석있는 태그를 생성합니다. 메시지와 태그이름은 필수이며 브랜치를 생략하면 HEAD에 태그를 생성합니다.
    * git push <원격저장소 별명> <태그이름> : 원격저장소에 태그를 업로드합니다.

* 버그 처리 시나리오, 3-Way merge
  1. (옵션)오류가 없는 버전으로(주로 Tag가 있는 커밋) 롤백.
  2. master 브랜치로부터 hotfix 브랜치 생성
  3. 소스코드 수정/ 테스트까지 완료
  4. master 브랜치로(master 브랜치에서) 병합 (fast-forward) 및 배포
  5. 개발 중인 브랜치에도 병합(master 브랜치와) (충돌 발생 가능성 높음)
* 명령어 활용 : git checkout -b hotfix master : master브랜치로부터 hotfix브랜치를 생성 및 체크아웃한다.

* rebase 사용하기
* rebase 원리
  1. HEAD와 대상 브랜치의 공통 조상을 찾는다.
  2. 공통 조상 이후에 생성한 커밋들을 대상 브랜치 뒤로 재배치한다. rebase한 커밋들은 기존 커밋과는 다른, 새로운 커밋이 된다.
* rebase는 주로 로컬 브랜치를 정리하고 싶을 때 사용한다. 원격에 푸시한 브랜치에 대해서는 rebase 하지 말 것을 권고한다.
* merge는 충돌 발생 시, 충돌 사항을 수정 후 마지막 단계에서 git commit을 사용하지만 rebase는 git rebase --continue 명령을 사용한다.
* **reset --hard로 병합 커밋을 되돌리고 rebase를 이용하면 커밋이 삐져 나왔다가 다시 병합된 형태를 깔끔하게 정리할 수 있다.**
* 원격저장소에 푸시한 브랜치는 rebase하지 않는 것이 원칙이다. 같은 내용의 커밋이 이름만 바뀌어서 존재하게 돼, 히스토리 꼬일 가능성이 높다.
* **가급적 rebase는 아직 원격에 존재하지 않는 로컬의 브랜치들에만 적용하자**

* merge와 rebase의 차이
  * merge : merge커밋 생성, 한 번만 충돌 발생, 트리가 약간 지저분해짐
  * rebase : 현재 커밋들을 수정하면서 대상 브랜치 위로 재배치함. 깔끔한 히스토리, 여러 번 충돌이 발생할 수 있음

* 임시브랜치를 사용하자
* merge, rebase 시 원래 작업하려고 했던 브랜치의 커밋으로 임시 브랜치를 만들고 나면 해당 브랜치에서는 아무 작업이나 막 해도 상관이 없다.
* 나중에 그 브랜치를 삭제하기만 하면 모든 내용이 원상 복구된다.
* 'git branc -D <브랜치 이름>' 명령으로 삭제할 수 있다.

## Git 내부 동작 원리
* 해시 체크섬은 같은 내용의 파일의 경우 언제나 똑같은 값이 나온다.
* git status : status는 워킹트리의 상태를 보는 명령
  * 워킹트리와 스테이지, 그리고 HEAD커밋 세가지 저장공간의 차이를 비교해서 보여준다.
  * 초기상태에서 파일하나를 생성한 직후, 워킹트리에는 생성한 파일이 보이고, 스테이지는 비어있으며, HEAD커밋은 아직 없다.
  * git status를 통해 clean 하다는 말은 워킹트리 = 스테이지 = HEAD 커밋인 상태로 세개 모두 같은 상태, 즉 커밋이후 변경사항이 없는 상태이다.
  * 수정한 파일을 modified라고 하며, modified는 스테이지와 워킹트리의 내용이 다른 파일을 일컫는다.
* git add
  * .git/index : 초기상태에서 파일하나를 add를 통해 스테이징하면, .git폴더안에 index파일이 생성된다. 이 index파일이 바로 스테이지다.
  * .git/objects/ : 이 디렉토리 밑에 Git 객체가 저장된다. 디렉토리명과 디렉토리 안 파일명을 합쳐 git객체의 체크섬값을 저장한다.
  * blob = binary large object, 스테이지에 올라간 파일 객체는 blob이 된다.
  * 즉, **git add는 워킹트리에 존재하는 파일을 스테이지에 추가하는 명령이다.**
  * 이 때, 해당 파일의 체크섬값과 동일한 이름을 가지는 blob 객체가 생성되고 이 객체는 .git/objects/ 폴더에 저장된다 그리고 스테이지 내용은 .git/index에 기록된다.

* git commit
  * **스테이지의 내용을 가지고 트리 객체를 만들고 이 트리 객체를 기반을 기존 HEAD 커밋을 부모로 하는 새로운 커밋을 만든다. 이로써 생성된 커밋이 다시 HEAD가 된다.**
  * 커밋도 객체이다. 그리고 객체는 당연히 .git/objects/에 저장된다.
  * 모든 커밋은 체크섬이 다르기 때문에, 내용이 같아도 100% 다른 체크섬을 갖는다.
  * commit을 보내도 stage에는 해당 파일들이 여전히 올라와 있다. 변경사항이 생기면 다음 add시 해당 파일들이 교체되는 것이다.
  * git commit 명령은 이전 HEAD를 부모로 하는 커밋 객체를 생성한후 방금 만든 새 커밋이 새로운 HEAD가 된다.
  * 커밋 객체는 부모 커밋에 대한 참조를 가지고 있다.
* Git tree객체
  1. commit을 하면 스테이지의 객체로 트리객체가 만들어진다. 
  2. 커밋에는 커밋 메시지와 트리객체가 포함된다. (커밋 객체는 트리객체와 blob 객체들의 조합으로 이루어져 있다.)
  * tree객체를 이용해 직접 커밋을 생성하면 HEAD가 갱신되지 않아, git log로 볼 수 없다.
  * 따라서 아래 HEAD에 update-ref 명령을 통해 HEAD를 직접 갱신해야 한다.
* HEAD
  * .git/HEAD 파일에는 refs/heads/master라는 내용이 들어있다. (현재 HEAD가 master 브랜치를 가르킨다.)
  * .git/refs/heads/master의 내용을 확인해 보면, 현재 HEAD커밋의 체크섬 값이 저장되어 있다. 
  * **git update-ref refs/heads/master <체크섬>** 을 이용해서 새로운 커밋의 체크섬 값으로 변경할 수 있다.(HEAD를 업데이트시킨다.)
* 중복 파일 관리
* git에서 파일은 blob으로 관리된다. git의 blob은 내용이 같은 경우 같은 체크섬을 갖는다.
* 이전 blob(스테이지에 올라간 파일객체는 blob으로 관리) 객체를 활용한 커밋을 하면 저장소에 별도의 blob객체가 추가로 생기지 않는다.
* 다시 말해 새로운 커밋을 여러 개 만들거나 같은 파일을 다른 폴더 등에 복사해서 여러개 만들어도 그 안의 파일은 같은 내용이라면 하나의 blob으로 관리되므로 사용자는 신경쓸 필요가 없다. 또한 이로써 git은 빠르고 효율적으로 동작할 수 있다.

* Branch
* 브랜치는 커밋의 참조일 뿐이다. 브랜치를 생서하면 .git/refs/heads/ 디렉토리에 생성한 브랜치이름의 파일이 생긴다.
* 파일의 내용은 브랜치를 만든, HEAD 커밋의 전체 체크섬 내용이 들어가있다. 이것이 브랜치의 전부이며 정체다.
  1. git branch test <커밋체크섬> : 내부적으로 <커밋체크섬> 내용을 가지는 .git/refs/heads/test 텍스트 파일을 하나 생성한다.
  2. git branch -d <브랜치이름> : 브랜치를 삭제하는 명령, 즉 단순하게 .git/refs/heads/에 있는 브랜치 파일을 삭제한다.
    * 즉 git branch -d 명령 대신 'rm .git/refs/heads/~' 명령을 사용해도 결과는 같다.
* 브랜치 checkout
* 브랜치 checkout도 간단하게 수행된다. 먼저 .git/HEAD 파일의 내용을 참조하는 브랜치로 변경하고, 워킹트리와 스테이지 내용을 해당 커밋의 내용으로 변경해준다.
* 즉, **체크아웃은 해당 브랜치로 HEAD를 이동시키고 스테이지와 워킹트리를 HEAD가 가르키는 커밋과 동일한 내용으로 변경한다.**
* 직접 .git/HEAD 파일을 수정하고, reset --hard를 이용해서 스테이지와 워킹트리 내용 초기화 과정을 통해 체크아웃 명령을 수동으로 수행할 수 있다.
  * reset --hard를 수행하면 커밋, 스테이지, 워킹트리의 내용이 모두 같아지게 된다.


## 인증
* 윈도우 자격증명(Credential) 관리 : 인증(로그인) 관련으로 이슈가 발생했을 때 해결하는 방법
  * git에는 인증과 관련되어 credential.helper 옵션이 있다. 이 변수의 값과 동작 방식은 운영체제마다 다르다
    * git config [--local] or [--global] or [--systme] credential.helper : credential.helper 옵션값을 확인
    * cache, store 값도 올 수 있지만 윈도우에선 일반적으로 manager 사용
    * manager로 설정되어 있을 경우 git은 윈도우에서 제공하는 자격 증명 관리자에 사용자 인증 관련 정보를 저장한다.
    * 윈도우 [시작]->[자격 증명 관리자]->[윈도우 자격 증명]
    * 아이디를 바꿔 로그인을 시도하던 중, 로그인 창이 뜨지않는 이슈가 발생했을 경우 기존의 자격증명을 제거한다. [삭제]
    * 그후 git push 명령을 수행하면 로그인을 위해 github 로그인 창이 난타난다.
* macOS에서 인증관련 사용자 옵션 : manager 대신 osxkeychain을 사용. '키체인 접근'이라는 앱에서 윈도우와 비슷하게 관리가능
* 리눅스에서 인증관련 옵션 관리 : 기본 설정에서 credential.helper에 아무 옵션이 지정돼있지 않음. => 매번 사용자 아이디 패스워드를 물어본다.
  * 이를 해결하기 위해 cache 또는 store옵션을 사용할 수 있다.
    * cache 옵션 : 지정한 시간만큼 사용자 아이디와 패스워드를 일시적으로 저장
      * git config credential.helper "cache --timeout=3600" : 1시간동안 저장, 1시간 지난면 다시 아이디, 패스워드를 입력해줘야 한다.
    * store 옵션 : 한 번 입력한 아이디와 패스워드를 영구적 저장
      * git config credential.helper store : 문제점으로 사용자의 아이디, 패스워드가 홈폴더의 .git-credentials  파일에 저장된다.
      * 인증 초기화 : 아래 1~3을 실행한다.
        1. git config --unset credential.helper : 옵션 삭제
        2. file ~/.git-credentials : 인증 파일 정보확인
        3. rm ~/.git-credentials : 인증 파일삭제
      
* ssh 방식 인증 : 공개키/비공개키 인증 방식 사용
  1. ssh키 생성
  2. GitHub에 공개키 등록, [settings]->[personal settings]->[New SSH key]
  3. SSH 설정 파일 생성
    * echo "Host github.com" >> ~/.ssh/config : SSH설정파일을 만든다. 아래에서 내용 수정
      1. Host github.com
      2.   Hostname github.com    //앞에 스페이스 두칸
      3.   IdentityFile ~/.ssh/id_rsa
  
* HTTPS와 SSH 주소
  * HTTPS를 사용하는 주소 : https://github.com/jang-namu/exampleRepo
  * SSH를 사용하는 주소 : git@github.com:jang-namu/exampleRepo
  