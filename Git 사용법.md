## git

git : 소스코드 버전관리 시스템, github : git으로 관리하는 프로젝트를 올려둘 수 있는 git 호스팅 사이트
Git Bash : 리눅스 기반 터미널. 리눅스, 맥과 같은 운영체제의 터미널과 같은 명령어로 git을 관리할 수 있게 해준다.
.git : 최초 'git init' 실행 시 자동 생성되는 파일로 git으로 생성한 버전들의 정보와 원격저장소의 주소 등을 저장한다. 로컬저장소라고 부른다.
커밋(commit) : git(버전관리)을 통해 생성된 각각의 버전.
.md 확장자 : 마크다운 문서. .txt 확장자와 마찬가지로 텍스트문서 파일이다. 특정 문법을 이용하여 서식을 지정할 수 있다.
origin : 연결한 원격저장소의 닉네임(주소)
master : 커밋을 올리는 '줄기'

## Setting
* git init : 현재 폴더를 git 로컬저장소(Local repository)로 만든다 or 초기화시킨다.
* commit을 생성하기 전에, 먼저 사용자 정보를 등록해야 한다. (각 버전의 생성자를 명시)
  * git config --global user.email "example@email.com"
  * git config --global user.name "exampleName"
  * config는 환결설정이라는 의미. 일반적으로 프로그램의 설정을 저장하는 파일을 의미한다.


## Using Local
* git add [fileName] : commit에 추가할 파일을 선택한다
* git commit -m [message] : 해당 버전에 대한 설명이나 추가/수정된 내용 등. commit에 상세설명을 작성한다.
* git log : 현재까지 만들었던 commit을 확인한다. 최신 commit부터 보여준다.

* git checkout [commitId] : 해당 commit으로 버전을 되돌린다. commitId는 전체를 써도되지만, 일반적으로 앞에서부터 7글자를 사용한다.
* git checkout - : 최신 commit으로 버전을 되돌린다. '-' 가 최신 commit을 의미한다.


## Using with Github
* Local to Remote repository
 * 로컬저장소에 commit을 원격저장소(Remote repository)에 올리기 위해선, 먼저 로컬저장소에 원격저장소 주소를 알려야한다.
 * git remote add origin "https://github.com/username/example" : Github 등에서 생성한 원격저장소의 주소를 로컬저장소에 알린다.
 * git push origin master : 로컬저장소의 commit을 원격저장소에 올린다.

* Remote to Local repository
 * 클론(Clone) : 원격저장소의 코드와 버전 전체를 내 컴퓨터로 내려받는 것. 최시 버전뿐 아니라 이전 버전들과 원격저장소의 주소 등이 내 컴퓨터에 로컬저장소에 저장된다.
 * 원격저장소의 정보를 클론해오고 싶을 경우, 먼저 내려받을 위치(로컬저장소)를 지정해줘야 한다. 
 * Download ZIP : Github에서 지원하는 다운로드 기능. 원격저장소 주소와 버전정보가 제외된다.
 * git clone [Github 주소] . : 해당 Github 페이지에 저장소를 내려받는다. 주소 이후 한칸 공백 후 '.'은 현재 위치에 내려받으라는 것. 미작성 시 해당 저장소 이름으로 폴더가 생성된다.
 * git pull origin master : 원격저장소의 커밋을 로컬저장소에 내려받는다.


## Using GUI sourcetree
* [Sourcetree-Atlassian] (https://www.sourcetreeapp.com/)
sourcetree는 git을 이용한 프로젝트 관리를 GUI환경, 다시말해 클리과 화면조작으로 가능하게 만듭니다.
sourcetree는 직관적이며, 아름답기 때문에 많은 개발자들이 사용합니다.
sourcetree를 이용하면 commit을 그래프로 확인하고, 생소한 명령어 대신 누구나 쉽게 프로젝트 관리가 가능합니다.

* Get Remote Repository
  * Github의 아이디로 로그인하면 원격저장소가 자동으로 sourcetree에 올라옵니다.
  * Clone을 선택하여 원격저장소에 있는 프로젝트를 로컬에 내려받을 수 있습니다.
* Get Local Repository
  * 로컬저장소는 자동으로 추가되지 않아 수동으로 추가해줘야 합니다.
  * Add 기능을 이용하여 직관적으로 경로를 추가할 수 있습니다.
  * Create 기능은 내 컴퓨터에 새로운 로컬저장소를 생성합니다. 이것은 Git Bash에서 'git init' 명령을 수행한 것과 같은 의미를 갖습니다.

* about Local repository
  * sourcetree는 커밋을 그래프로 보여줍니다. 이는 .git 폴더에 저장된 정보를 사용합니다.
  * .git 폴더는 최초 'git init' 초기화 시, 생성되며 git은 .git폴더에 버전 관리한 데이터와 이를 올릴 원격저장소의 주소 등을 저장합니다.

* Commit
  * 로컬에서 에디터를 이용해 파일을 추가/삭제/수정 한 경우, sourcetree의 해당 repository로 이동하면 '커밋하지 않은 변경사항' 알림을 볼 수 있다.
  * 이는 기존 커밋에 비해 새로 만들어지거나 수정, 삭제된 파일의 목록을 보여준다.
  * 이러한 목록들의 파일을 커밋하기 위해선, 좌측 상단의 '커밋' 기능을 사용할 수 있다. 커밋기능에선 '+' 버튼을 클릭해 수정된 파일을 스테이지에 올릴 수 있고 commit에 멘션도 작성할 수 있다. 
  * CLI에서도 그렇듯이 모든 수정된 프로젝트는 Githube에 올라가기 전에(커밋되기 전에) git add 명령이나, sourcetree에 '커밋' -> '+' 버튼을 클릭한 것 처럼 스테이지에 먼저 올라간다.
  * 이렇게 커밋을 하게되면 로컬저장소(.git)에 기존 버전에 대한 정보가 저장되고, 기존 버전의 파일은 신규 커밋으로 바뀌게 된다.
  이 상태에서 원격저장소의 버전은 바뀌지 않으므로, 현재 원격저장소는 상대적으로 구버전을 가지고있다.
    * origin/master : 원격저장소의 현재 버전 상태.
    * master : 로컬저장소의 버전 상태.
  * 원격저장소와 로컬저장소의 버전을 맞추기 위해, 또는 원격저장소에 업로드할 목적이라면, 로컬저장소의 새로운 커밋을 'push' 해줘야한다.
    *push 과정을 거치면 로컬과 원격저장소의 버전을 맞출 수 있다.

* branch
  * Branch 이름에 '/'를 넣게되면( ex) feature/detail ), '/'앞에 feature가 폴더명인 폴더안에 detail파일을 만든 것 처럼 볼 수 있다.

## About git
* git의 커밋 저장 방식
  * 기존의 버전 관리 시스템과 git의 차이점은 git은 변경사항만을 저장하지 않고, 변경된 파일을 통째로 저장한다. 
  * 변경사항을 저장하기 위해선, 이전 버전과의 차이점을 일일히 계산해야하기 때문에 오히려 계산과정이 복잡해진다. 따라서 git은 변경사항이 있는지만 연산을 한다.
  * 또한, 바뀌지 않은 파일에 대해서는 이전 파일의 링크만을 저장하기 때문에 git은 여러 복잡한 명령어들을 빠르게 처리할 수 있다.
  * 소스트리에서 커밋을 선택했을 때에는 git이 자동으로 앞뒤 커밋을 차이점을 계산해서 보여준다.
  * 이러한 git의 저장 방식을 **Snapshot** 방식이라고 한다.
  
* git의 장점, branch
  * git의 branch는 포인터다. 따라서 가리키는 것 만으로 새로운 분기를 만들 수 있다.
  * SVN과 같은 버전 관리 툴은 새 분기를 만들기 위해 프로젝트를 통째로 복사하므로 무겁고, 시간이 많이 걸린ㄷ.
  * 반면, git의 branch는 독립적인 프로젝트를 따로 생성하지 않고 '가리키는' 방식이기 때문에 비교적 가볍고 빠르다.

## Git Status
  * git으로 관리되는 파일은 untracked(추적안됨), tracked(수정없음, 수정함, 스테이징됨)의 총 네가지 상태를 가진다.
  * 새로 파일을 만들경우 해당 파일은 untracked 상태가 된다.
  * add 명령을 통해 스테이지에 올릴 경우, 해당 파일을 스테이징 상태가 된다.
  * commit을 통해 스냅샷, 버전으로 만들면, 해당 파일들은 모두 수정없음 상태가 되고, 이렇게 수정없음 상태가 된 파일은 다시 다른 수정이 가능하다.
  * 수정없음 상태의 파일을 수정하면, '수정' 상태가 되고 해당 파일을 add하면 다시 '스테이징' 상태가 된다.
  * 주의할 점은 최초 add명령어를 통해 스테이지에 올려둔 파일들은 commit이나 push 이후 삭제되지 않았다는 점이다.
  * 따라서 add 명령을 통해 수정한 파일을 스테이지에 올릴 경우에만 원래 스테이징돼 있던 파일과 교체되고, **수정되지 않은 파일은 스테이지에 그대로 존재한다.**

## Branch
두명 이상의 개발자가 협업할 경우, 같은 버전(커밋)을 가지고 각각의 개발자가 수정할 수 있게한다.
일반적으로 혼자 개발하고 프로젝트를 관리할 때와 비교하자면, 혼자 개발하는 경우 커밋은 따로 줄기가 나눠지지 않고 시간순으로, 한 줄로 쌓이게 된다.
두명 이상의 개발자가 위와 같은 방식으로 같은 버전에서 프로젝트를 동시에 개발, 원격저장소에 푸쉬하게 될 경우 최초 커밋은 정상적으로 수행되지만, 
뒤늦게 푸시한 커밋은 이전 버전에 푸쉬를 하게되기 때문에 오류가 발생한다.
따라서 두 명 이상의 개발자가 동시에 협업하기 위해선, 한 줄이 아닌, 두 개 이상의 줄기로 나눠져야 한다. 즉, 분기가 필요하다.
현재 작업할 버전에 대해 여러 흐름(분기)을 만드는 것을 **Branch**라고 한다
* [master] 꼬리표 또한, 브랜치이다. [master]는 최신 버전의 커밋을 '가리키는' 브랜치다. (브랜치는 포인터와 같아서 '가리킨다'는 표현을 쓴다)
* Base : 새로운 branch를 만들어 분기가 여러 갈래로 나뉘었을 때, 해당 기준이 되는 커밋을 기준, base라고 한다.
* [HEAD] : [HEAD]는 브랜치 혹은 커밋을 가리키는 특수한 포인터다. 원하는 커밋을 [HEAD] 포인터가 가리키게 하면 과거 커밋으로 돌아갈 수도, 최신 브랜치로 돌아올 수도 있다.(checkout)
* [HEAD]를 조작해, [master] 브랜치가 아닌 다른 커밋이나 브랜치를 가리키는 상태를 분리된 HEAD(Detached Head)라고 한다.]

* Branch Rule
  1. [master] 브랜치에는 직접 커밋을 올리지 않는다(동시에 작업하다 꼬일 수 있으니)
  2. 기능개발을 하기 전에 [master] 브랜치를 기준으로 새로운 브랜치를 만든다
  3. 새로운 브랜치 이름은 [feature/기능이름] 형식으로 하고, 한 명만 커밋을 올린다.
  4. [feature/기능이름] 브랜치에서 기능 개발이 끝나면 [master]브랜치에 이를 합친다.