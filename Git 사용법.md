## git

git : 소스코드 버전관리 시스템, github : git으로 관리하는 프로젝트를 올려둘 수 있는 git 호스팅 사이트
Git Bash : 리눅스 기반 터미널. 리눅스, 맥과 같은 운영체제의 터미널과 같은 명령어로 git을 관리할 수 있게 해준다.
.git : 최초 'git init' 실행 시 자동 생성되는 파일로 git으로 생성한 버전들의 정보와 원격저장소의 주소 등을 저장한다. 로컬저장소라고 부른다.
커밋(commit) : git(버전관리)을 통해 생성된 각각의 버전.
.md 확장자 : 마크다운 문서. .txt 확장자와 마찬가지로 텍스트문서 파일이다. 특정 문법을 이용하여 서식을 지정할 수 있다.
origin : 연결한 원격저장소의 닉네임(주소)
master : 커밋을 올리는 '줄기'
Collaborator(협력) : 프로젝트의 주체, 정식적으로 초대받은 최초 프로젝트 개발자
Contributor(기여) : 오픈소스 프로젝트의 기여자. 
Gmail '+' 기능 : 회원가입 시, gmail을 이용하면 example@gmail.com, example+sub@gmail.com, example+05@gmail.com 등으로 '+' 뒤에 아무 글자를 붙여서 가입해도 exmaple@gmail.com으로 모든 메일을 받을 수 있다. 

## Setting
* git init : 현재 폴더를 git 로컬저장소(Local repository)로 만든다 or 초기화시킨다.
* commit을 생성하기 전에, 먼저 사용자 정보를 등록해야 한다. (각 버전의 생성자를 명시)
  * git config --global user.email "example@email.com"
  * git config --global user.name "exampleName"
  * config는 환결설정이라는 의미. 일반적으로 프로그램의 설정을 저장하는 파일을 의미한다.


## Using Local
* git add [fileName] : commit에 추가할 파일을 선택한다
* git commit -m [message] : 해당 버전에 대한 설명이나 추가/수정된 내용 등. commit에 상세설명을 작성한다.
* git log : 현재까지 만들었던 commit을 확인한다. 최신 commit부터 보여준다.

* git checkout [commitId] : 해당 commit으로 버전을 되돌린다. commitId는 전체를 써도되지만, 일반적으로 앞에서부터 7글자를 사용한다.
* git checkout - : 최신 commit으로 버전을 되돌린다. '-' 가 최신 commit을 의미한다.


## Using with Github
* Local to Remote repository
 * 로컬저장소에 commit을 원격저장소(Remote repository)에 올리기 위해선, 먼저 로컬저장소에 원격저장소 주소를 알려야한다.
 * git remote add origin "https://github.com/username/example" : Github 등에서 생성한 원격저장소의 주소를 로컬저장소에 알린다.
 * git push origin master : 로컬저장소의 commit을 원격저장소에 올린다.

* Remote to Local repository
 * 클론(Clone) : 원격저장소의 코드와 버전 전체를 내 컴퓨터로 내려받는 것. 최시 버전뿐 아니라 이전 버전들과 원격저장소의 주소 등이 내 컴퓨터에 로컬저장소에 저장된다.
 * 원격저장소의 정보를 클론해오고 싶을 경우, 먼저 내려받을 위치(로컬저장소)를 지정해줘야 한다. 
 * Download ZIP : Github에서 지원하는 다운로드 기능. 원격저장소 주소와 버전정보가 제외된다.
 * git clone [Github 주소] . : 해당 Github 페이지에 저장소를 내려받는다. 주소 이후 한칸 공백 후 '.'은 현재 위치에 내려받으라는 것. 미작성 시 해당 저장소 이름으로 폴더가 생성된다.
 * git pull origin master : 원격저장소의 커밋을 로컬저장소에 내려받는다.
 * clone과 pull의 차이 : clone 리모트 설정을 자동으로 해주는 초기 다운로드에 사용, pull은 리모트 설정이 이미 돼있을 때 업데이트 사항 등을 다운로드 할 때 사용한다.
 clone은 로컬과 원격저장소의 내용을 일치시키고 pull은 변경사항이 있을 경우 병합까지 수행한다.


## Using GUI sourcetree
* [Sourcetree-Atlassian] (https://www.sourcetreeapp.com/)
sourcetree는 git을 이용한 프로젝트 관리를 GUI환경, 다시말해 클리과 화면조작으로 가능하게 만듭니다.
sourcetree는 직관적이며, 아름답기 때문에 많은 개발자들이 사용합니다.
sourcetree를 이용하면 commit을 그래프로 확인하고, 생소한 명령어 대신 누구나 쉽게 프로젝트 관리가 가능합니다.

* Get Remote Repository
  * Github의 아이디로 로그인하면 원격저장소가 자동으로 sourcetree에 올라옵니다.
  * Clone을 선택하여 원격저장소에 있는 프로젝트를 로컬에 내려받을 수 있습니다.
* Get Local Repository
  * 로컬저장소는 자동으로 추가되지 않아 수동으로 추가해줘야 합니다.
  * Add 기능을 이용하여 직관적으로 경로를 추가할 수 있습니다.
  * Create 기능은 내 컴퓨터에 새로운 로컬저장소를 생성합니다. 이것은 Git Bash에서 'git init' 명령을 수행한 것과 같은 의미를 갖습니다.

* about Local repository
  * sourcetree는 커밋을 그래프로 보여줍니다. 이는 .git 폴더에 저장된 정보를 사용합니다.
  * .git 폴더는 최초 'git init' 초기화 시, 생성되며 git은 .git폴더에 버전 관리한 데이터와 이를 올릴 원격저장소의 주소 등을 저장합니다.

* Commit
  * 로컬에서 에디터를 이용해 파일을 추가/삭제/수정 한 경우, sourcetree의 해당 repository로 이동하면 '커밋하지 않은 변경사항' 알림을 볼 수 있다.
  * 이는 기존 커밋에 비해 새로 만들어지거나 수정, 삭제된 파일의 목록을 보여준다.
  * 이러한 목록들의 파일을 커밋하기 위해선, 좌측 상단의 '커밋' 기능을 사용할 수 있다. 커밋기능에선 '+' 버튼을 클릭해 수정된 파일을 스테이지에 올릴 수 있고 commit에 멘션도 작성할 수 있다. 
  * CLI에서도 그렇듯이 모든 수정된 프로젝트는 Githube에 올라가기 전에(커밋되기 전에) git add 명령이나, sourcetree에 '커밋' -> '+' 버튼을 클릭한 것 처럼 스테이지에 먼저 올라간다.
  * 이렇게 커밋을 하게되면 로컬저장소(.git)에 기존 버전에 대한 정보가 저장되고, 기존 버전의 파일은 신규 커밋으로 바뀌게 된다.
  이 상태에서 원격저장소의 버전은 바뀌지 않으므로, 현재 원격저장소는 상대적으로 구버전을 가지고있다.
    * origin/master : 원격저장소의 현재 버전 상태.
    * master : 로컬저장소의 버전 상태.
  * 원격저장소와 로컬저장소의 버전을 맞추기 위해, 또는 원격저장소에 업로드할 목적이라면, 로컬저장소의 새로운 커밋을 'push' 해줘야한다.
    *push 과정을 거치면 로컬과 원격저장소의 버전을 맞출 수 있다.

* Branch
  * Branch 이름에 '/'를 넣게되면( ex) feature/detail ), '/'앞에 feature가 폴더명인 폴더안에 detail파일을 만든 것 처럼 볼 수 있다.

* Add multi remote repository
  * source tree를 이용하면 하나의 로컬저장소에서 두 개 이상의 원격저장소를 관찰할 수 있다.
  * 상단의 [저장소]-[원격 저장소 추가]를 통해 하나의 로컬저장소에서 여럿 원격저장소를 추적할 수 있다.
  * [원격 저장소 추가] 기능은 CLI에서 'git remote add origin [원격저장소주소]'를 수행한 것과 같다.
  * upstream : 원격저장소를 지칭하는 관용적 닉네임
  * 원격저장소를 추가한 후에, 해당 저장소에 대한 추적을 시작하기 위해선, Fetch 과정을 거쳐야한다. 해당 원격저장소에서 [...에서 가져오기] 기능을 사용할 수 있다.

## About git
* git의 커밋 저장 방식
  * 기존의 버전 관리 시스템과 git의 차이점은 git은 변경사항만을 저장하지 않고, 변경된 파일을 통째로 저장한다. 
  * 변경사항을 저장하기 위해선, 이전 버전과의 차이점을 일일히 계산해야하기 때문에 오히려 계산과정이 복잡해진다. 따라서 git은 변경사항이 있는지만 연산을 한다.
  * 또한, 바뀌지 않은 파일에 대해서는 이전 파일의 링크만을 저장하기 때문에 git은 여러 복잡한 명령어들을 빠르게 처리할 수 있다.
  * 소스트리에서 커밋을 선택했을 때에는 git이 자동으로 앞뒤 커밋을 차이점을 계산해서 보여준다.
  * 이러한 git의 저장 방식을 **Snapshot** 방식이라고 한다.
  
* git의 장점, branch
  * git의 branch는 포인터다. 따라서 가리키는 것 만으로 새로운 분기를 만들 수 있다.
  * SVN과 같은 버전 관리 툴은 새 분기를 만들기 위해 프로젝트를 통째로 복사하므로 무겁고, 시간이 많이 걸린ㄷ.
  * 반면, git의 branch는 독립적인 프로젝트를 따로 생성하지 않고 '가리키는' 방식이기 때문에 비교적 가볍고 빠르다.

## Git Status
  * git으로 관리되는 파일은 untracked(추적안됨), tracked(수정없음, 수정함, 스테이징됨)의 총 네가지 상태를 가진다.
  * 새로 파일을 만들경우 해당 파일은 untracked 상태가 된다.
  * add 명령을 통해 스테이지에 올릴 경우, 해당 파일을 스테이징 상태가 된다.
  * commit을 통해 스냅샷, 버전으로 만들면, 해당 파일들은 모두 수정없음 상태가 되고, 이렇게 수정없음 상태가 된 파일은 다시 다른 수정이 가능하다.
  * 수정없음 상태의 파일을 수정하면, '수정' 상태가 되고 해당 파일을 add하면 다시 '스테이징' 상태가 된다.
  * 주의할 점은 최초 add명령어를 통해 스테이지에 올려둔 파일들은 commit이나 push 이후 삭제되지 않았다는 점이다.
  * 따라서 add 명령을 통해 수정한 파일을 스테이지에 올릴 경우에만 원래 스테이징돼 있던 파일과 교체되고, **수정되지 않은 파일은 스테이지에 그대로 존재한다.**

## Branch
두명 이상의 개발자가 협업할 경우, 같은 버전(커밋)을 가지고 각각의 개발자가 수정할 수 있게한다.
일반적으로 혼자 개발하고 프로젝트를 관리할 때와 비교하자면, 혼자 개발하는 경우 커밋은 따로 줄기가 나눠지지 않고 시간순으로, 한 줄로 쌓이게 된다.
두명 이상의 개발자가 위와 같은 방식으로 같은 버전에서 프로젝트를 동시에 개발, 원격저장소에 푸쉬하게 될 경우 최초 커밋은 정상적으로 수행되지만, 
뒤늦게 푸시한 커밋은 이전 버전에 푸쉬를 하게되기 때문에 오류가 발생한다.
따라서 두 명 이상의 개발자가 동시에 협업하기 위해선, 한 줄이 아닌, 두 개 이상의 줄기로 나눠져야 한다. 즉, 분기가 필요하다.
현재 작업할 버전에 대해 여러 흐름(분기)을 만드는 것을 **Branch**라고 한다
* [master] 꼬리표 또한, 브랜치이다. [master]는 최신 버전의 커밋을 '가리키는' 브랜치다. (브랜치는 포인터와 같아서 '가리킨다'는 표현을 쓴다)
* Base : 새로운 branch를 만들어 분기가 여러 갈래로 나뉘었을 때, 해당 기준이 되는 커밋을 기준, base라고 한다.
* [HEAD] : [HEAD]는 브랜치 혹은 커밋을 가리키는 특수한 포인터다. 원하는 커밋을 [HEAD] 포인터가 가리키게 하면 과거 커밋으로 돌아갈 수도, 최신 브랜치로 돌아올 수도 있다.(checkout)
* [HEAD]를 조작해, [master] 브랜치가 아닌 다른 커밋이나 브랜치를 가리키는 상태를 분리된 HEAD(Detached Head)라고 한다.]

* Branch Rule
  1. [master] 브랜치에는 직접 커밋을 올리지 않는다(동시에 작업하다 꼬일 수 있으니)
  2. 기능개발을 하기 전에 [master] 브랜치를 기준으로 새로운 브랜치를 만든다
  3. 새로운 브랜치 이름은 [feature/기능이름] 형식으로 하고, 한 명만 커밋을 올린다.
  4. [feature/기능이름] 브랜치에서 기능 개발이 끝나면 [master]브랜치에 이를 합친다.

## Merge, 병합
* Merge commit : 두 커밋의 합집합(두 커밋 모두 수정된 내용일 경우)
* Fast-Forward : 한 커밋의 모든 내용이 다른 커밋에 종속될 경우
* Conflict : 수정된 부분이 중복될 경우, 무엇을 선택해야할지 결정해야되는 상태

* 병합 과정 
  1. [master] 브랜치를 기준으로 나뉜 여러개의 브랜치 중, 최초로 개발을 완료한 파트가 Fast-Forward 과정을 거쳐 [master] 브랜치가 된다
  2. 뒤이어 개발이 완료된 브랜치와 1의 과정을 거쳐 생성된 [master] 브랜치가 Merge commit이 된다. 
  3. 병합커밋이 생성될 때, 둘 중 어떤 브랜치에 새로운 병합커밋을 올린것인지 선택이 가능하다.

* Conflict, 충돌 발생 우려가 있는 경우
  1. 같은 분기에서 나눠진 두 커밋이 같은 코드를 고치게 되는 경우, 충돌이 일어날 수 있다.
  2. 따라서 Merge commit을 만드는 경우, 충돌이 발생할 수 있으므로 [master] 브랜치에 바로 병합하기보단 개인이 개발한 브랜치에서 먼저 병합해보고 문제가 없는지 확인한다.
  3. 병합된 커밋이 문제가 없음을 확인하고 나서 병합 커밋을 [master] 브랜치에 반영한다.
  
* Pull request : 내가 수정한 A 브랜치를 B브랜치에 병합해도 될까? 수정사항은 다음과 같아.
  1. 병합 시, 충돌만 해결했다고 [master] 브랜치에 병합하게 되면 [master]는 뒤죽박죽인 코드가 될 것이다.
  2. 따라서, 병합 전에 각 파트의 수정된 부분을 이해하고 서로 협력하기 위해, 다른 Collabrators가 확인하는 과정을 거친다.
  3. 이와 같이 브랜치 병합을 요청하는 메세지를 보내는 것을 풀 리퀘스트, **Pull request**라고 한다.
  4. Github에 Pull request에서는 코드의 라인별로 코멘트를 달아 개선방법이나, 변경사항에 대한 설명에 대해 토론할 수 있다.
  5. Github에서 Pull request를 통해 병합 후, 병합 결과를 소스트리에서 확인하기 위해선 **패치**를 해야한다.
  6. 패치(Fetch)는 새로고침과 같은 역할로, git에서 새로운 이력을 업데이트하는 명령어이다. (원격저장소의 커밋 히스토리를 받아온다.) 패치는 그래프만 업데이트한다는 면에서 실제 코드를 내려받는 Pull과는 차이점을 갖는다.

## Relesase와 Version
* 프로그램을 출시하는 것을 릴리즈(Release)라고 한다. 프로그램이 출시될 때, 일반적으로 프로그램의 버전을 명시한다. 
* 프로그램의 버전은 일반적으로 Major 업그레이드와 Minor 업그레이드로 나뉜다. 큰 변화가 일어난 경우 Major 버전을 올리고, 작은 변화 등이 생겼을 경우 Minor 버전을 올린다.
* 이외에도 메인터넌스 Maintenance 버전이란 것도 존재하는데, 이는 버그나 유지보수 등 작은 수정을 의미한다.
* 프로그램의 버전은 태그로 가리킬 수 있다. 태그는 특정 커밋에 짧은 내용의 포스트잇을 붙이는 것과 같다. '가리킨다'는 표현을 쓴 것은 태그 또한 포인터이기 때문이다.
* 태그 또한 푸시를 해줘야 원격저장소에서 확인할 수 있다. 이렇게 Github의 태그를 푸시하게되면, Release 페이지에서 해당 버전을 다운로드 받을 수 있다.


## fork, 다른 사람의 프로젝트에 추가한다.
fork는 남의 원격저장소를 내 계정의 원격저장소로 복사해오는 명령이다.
fork를 통해 원격저장소를 복사해 오는 것은, 프로젝트에 직접 커밋을 올리는 것과는 다르다. 
일반적으로 contributor는 남의 프로젝트에 커밋을 올릴 권한이 없다. Github 에서는 이름없는 참여자들의 참가를 위헤 원격저장소를 복사해오는, fork 기능을 제공한다.
다른 사람의 프로젝트를 복사해서 본인의 Github로 새로운 원격저장소를 만들고 마음대로 수정할 수 있다. 수정사항은 내 저장소에만 반영된다.
* 개발자는 fork를 통해 복사해온 원격저장소에 코드를 수정하고, 프로젝트 소유자에게 Pull request, 병합요청을 보낸다. 프로젝트 소유자는 병합 요청을 검토해서 프로젝트 원본에 반영한다.
* fork를 통해 남의 원격저장소를 복사해 올 경우, 최신 커밋뿐만 아니라 과거의 모든 커밋 이력을 통째로 복사해오게 된다.
* fork는 분기를 나눈다는 점에서 branch와 공통점을 갖는다. branch는 하나의 저장소에서 fork는 여러 저장소로 분기를 나눈다.

## Rebase(재배치), 커밋의 이력을 조작하다
협업을 하다보면 프로젝트 원본의 업데이트로 인해, 개발하고 있는 브랜치의 base가 상대적으로 구버전이 될 때가 있다.
또한, 이 과정에서 서로 같은 부분을 수정했다면 충돌이 일어날 우려가 있다. 이를 위한 해결방안 두가지를 설명한다.
1. 프로젝트 원본이 아닌, 기능 개발을 하고있는 다른 브랜치에 업데이트된 프로젝트 원본과의 병합커밋을 만들어 충돌을 해결한다.
  * 이 방법은 개발 브랜치에 불필요한 병합커밋이 하나 더 생긴다는 단점이 있다. 
2. 기능 개발 브랜치의 base를 프로젝트 원본의 [master]로 base를 이동시킨다. **Rebase**
  * 이렇게되면 프로젝트 원본의 최신커밋이 base가 되기 때문에, 병합시에 충돌없이 fast-forward를 수행한다.
  * 발생하는 충돌은 Rebase 시에 조용히 해결한다.

* Rebase는 이력을 강제 조작한다. 해당 히스토리를 보고있는 다른 개발자가 있다면 완전히 꼬여버리게 된다. 따라서, Rebase는 반드시 혼자 사용하는 브랜치에서만 해야한다.
* Rebase는 이러한 위험성을 갖기 때문에, 일반적인 push가 아닌 **강제 푸시**를 해줘야 한다.

## Amend, 커밋을 수정하다.
작업 후, 파일을 빼놓고 커밋을 올리거나 커밋 메세지를 잘못써서 보낼 때가 있다. 이 때 커밋을 하나 더 만들지 않고 이전 커밋을 수정하는 것이 amend다.
[Amend last commit]을 이용하면, 커밋의 내용이나 메세지를 수정할 수 있다. 이미 잘못된 커밋으로 원격저장소에 푸시까지 한 상황이라면, 로컬의 커밋을 수정 후 **강제 푸시**해야 한다.
강제 푸시는 로컬저장소의 변경사항을 원격저장소에 강제로 덮어씌우며 푸시하는 명령이다. 공용으로 사용하느 브랜치에서 강제푸시를 하면 다른 사람의 커밋 히스토리가 꼬이게 된다.
**강제푸시는 반드시 혼자만 쓰고있는 브랜치에서 실행해야 한다.**

## git workflow
[우아한 형제들 블로그](https://techblog.woowahan.com/2553/)
git flow는 git을 이용하여 개발할 때, 브랜치를 관리하는 전략이다.
기본적으로 master, develop, feature, release, hotfix 5가지 종류의 브랜치로 나눈다.
항상 유지되는 main 브랜치(mater, develop)과 일정 기간만 유지되는 브랜치(feature, release, hotfix) 브랜치가 있다.
* master : 바로 배포될 수 있는 브랜치. 큼직큼직한 개발이 완료된 버전이 올라가는 브랜치. release가 merge 되면 새로운 버전 태그를 붙인다.
* develop : 기능 개발 등 다음 버전을 만드는 브랜치
* feature : 기능 개발을 위해 develop 브랜치를 base로 만들어낸 브랜치. 기능 개발이 완료되면 develop 브랜치로 merge
* release : 기능 개발이 종료된 후, 프로그램 배포 전 QA를 위해 develop에서 생성한 브랜치. QA 시 발생하는 수정사항들은 release에 직접 반영한다. QA를 통과하면 develop과 master로 merge한다.
* hotfix : 현재 출시 버전에서 발생한 버그, 극심한 버그들을 긴급하게 수정하는 브랜치. 

## cherry-pick, 다른 브랜치의 원하는 커밋만 쏙 빼간다.
개발을 하다보면, 특히나 hotfix와 같은 버그 수정을 위해, 다른 브랜치의 특정 커밋만을 반영하고 싶을 때가 있다.
다른 브랜치의 커밋을 반영하기 위해 앞서 해왔던대로 병합을 할 수도 있다. 하지만 병합의 문제는 그 이전이나 이후의 커밋도 같이 적용된다는 것이다. 
그 누구도 기능 개발 중인 내용을 master에 올리고 싶지 않을 것이다. 이럴 때 **cherry pick**을 사용하면 원하는 특정 커밋만을 빼올 수 있다.

## reset, 옛날 커밋으로 브랜치를 되돌리다.
기능 개발을 완료한 브랜치에서, 해당 기능이 더이상 필요없어질 경우 현재까지의 작업이력을 커밋으로 남겨놨다면 손쉽게 돌아갈 수 있다.
이와 같이 옛날 버전(커밋)으로 브랜치를 되돌리는 일을 수행하는 명령이 **reset**이다. reset에는 3가지 옵션이 있다.
1. [Soft] : 원하는 커밋으로 이력을 되돌릴 때, 이후 추가했던 모든 변경사항을 스테이징 상태로 놓는다.
2. [Mixed] : 원하는 커밋으로 이력을 되돌릴 때, 이후 추가했던 모든 변경사항을 스테이지 아래로 내린다.
3. [Hard] : 원하는 커밋으로 강제적으로 되돌린다. 이후 추가했던 모든 변경사항을 무시(삭제)한다.
* 이미 push한 브랜치를 예전 커밋으로 깔끔하게(Hard 옵션) 되돌리기 위해선, 로컬의 reset을 수행한 후에 수행 내용을 **강제푸시**해야 한다.
* 이는 히스토리를 수정하는 푸시이기 때문이다. 다시 한 번 말하지만, 강제푸시는 히스토리를 꼬이게 만들 수 있기 때문에 혼자 사용하는 브랜치에서만 사용하도록 한다.

## revert, 커밋의 변경사항을 되돌리며 **기록을 남긴다.**
이력관리가 중요한 함께 쓰는 브랜치에서는 기록이 안 남는 reset보다 변경사항을 되돌리는 새로운 커밋을 만드는 것이 좋다.
revert, 커밋 되돌리기를 사용하면 바로 이전에 올린 커밋뿐 아니라 예전에 올린 커밋도 얼마든 되돌릴 수 있다.

## stash, 변경사항을 잠깐 저장했다가 나중에 다시꺼내 쓴다.
개발중인 브랜치에서 다른 브랜치로 이동해야 할 경우, 커밋하지 않은 파일들이 아직 커밋으로 만들기 애매할 때 잠깐 저장했다 나중에 다시 꺼낼 쓸 수 있다.
stash, 스태시 명령은 현재 브랜치의 변경사항을 저장한다. 현재 변경사항들에 대해 stash 명령을 수행할 경우, 현재 브랜치는 더 이상 커밋할 것도 수정사항도 없는 
깨끗한 상태로 돌아간다. 이 상태에서 다른 작업을 수행 후, 다시 stash에 저장된 변경사항들을 적용해 꺼내쓰면 된다.